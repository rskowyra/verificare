/*** Generated by Spin Version 2.9.3 -- 5 October 1996 ***/
/*** From source: pan_in ***/

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#define Offsetof(X, Y)	((int)(&(((X *)0)->Y)))
#include "pan.h"

#ifndef max
#define max(a,b) (((a)<(b)) ? (b) : (a))
#endif
#ifdef CNTRSTACK
#define onstack_now()	(LL[trpt->j6] && LL[trpt->j7])
#define onstack_put()	 LL[trpt->j6]++; LL[trpt->j7]++
#define onstack_zap()	 LL[trpt->j6]--; LL[trpt->j7]--
#endif
#if !defined(SAFETY) && !defined(NOCOMP)
#define V_A	(((now._a_t&1)?2:1) << (now._a_t&2))
#define A_V	(((now._a_t&1)?1:2) << (now._a_t&2))
int	S_A = 0;
#else
#define V_A	0
#define A_V	0
#define S_A	0
#endif
#if defined(FULLSTACK) && !defined(BITSTATE)
#define onstack_put()	trpt->ostate = Lstate;
#define onstack_zap()	{ \
	if (trpt->ostate) \
		trpt->ostate->tagged = \
		(S_A)? (trpt->ostate->tagged&~V_A) : 0; \
	}
#endif
struct H_el {
	struct H_el *nxt;
#ifdef FULLSTACK
	unsigned tagged;
#if defined(BITSTATE) && defined(PARTIAL) && !defined(SAFETY)
	unsigned proviso;
#endif
#endif
#if defined(CHECK) || (defined(COLLAPSE) && !defined(FULLSTACK))
	unsigned st_id;
#endif
#ifdef COLLAPSE
	unsigned ln;
#endif
#ifdef REACH
	unsigned D;
#endif
	unsigned state;
} **H_tab, **S_tab;

typedef struct Trail {
	short st;	/* current state */
	uchar pr;	/* process id */
	uchar tau;	/* 8 different bit-flags */
	uchar o_pm;	/* a few more bit-flags */
#if 0
	Meaning of bit-flags:
	tau&1   -> timeout enabled
	tau&2   -> request to enable timeout 1 level up (in claim)
	tau&4   -> current transition is a  claim move
	tau&8   -> current transition is an atomic move
	tau&16  -> last move was truncated on stack
	tau&32  -> current transition is a preselected move
	tau&64  -> at least one next state is not on the stack
	tau&128 -> current transition is a stutter move
	o_pm&1	-> the current pid moved -- implements else
	o_pm&2	-> this is an acceptance state
	o_pm&4	-> this is a  progress state
	o_pm&8	-> fairness alg rule 1 undo mark
	o_pm&16	-> fairness alg rule 3 undo mark
	o_pm&32	-> fairness alg rule 2 undo mark
	o_pm&64 -> the current proc applied rule2
	o_pm&128 -> a fairness, dummy move - all procs blocked
#endif
	char  o_n, o_ot, o_m;	/* to save locals */
	short o_tt, o_To;
#ifdef HAS_UNLESS
	short e_state;	/* if escape trans - state of origin */
#endif
#ifdef FULLSTACK
	struct H_el *ostate;	/* pointer to stored state */
#endif
#ifdef CNTRSTACK
	int	j6, j7;
#endif
	Trans *o_t;
	int oval;
} Trail;
Trail	*trail, *trpt;
uchar	*this;
int	maxdepth=10000;
uchar	*SS, *LL;
uchar	HASH_NR = 0;
unsigned int HASH_CONST[] = {
	/* asuming 4 bytes per int */
	0x88888EEF,	0x00400007,
	0x04c11db7,	0x100d4e63,
	0x0fc22f87,	0x3ff0c3ff,
	0x38e84cd7,	0x02b148e9,
	0x98b2e49d,	0xb616d379,
	0xa5247fd9,	0xbae92a15,
	0xb91c8bc5,	0x8e5880f3,
	0xacd7c069,	0xb4c44bb3,
	0x2ead1fb7,	0x8e428171,
	0xdbebd459,	0x828ae611,
	0x6cb25933,	0x86cdd651,
	0x9e8f5f21,	0xd5f8d8e7,
	0x9c4e956f,	0xb5cf2c71,
	0x2e805a6d,	0x33fc3a55,
	0xaf203ed1,	0xe31f5909,
	0x5276db35,	0x0c565ef7,
	0x273d1aa5,	0x8923b1dd,
	0
};
int	mreached=0, done=0, errors=0, Nrun=1, single=0;
double	nstates=0, nlinks=0, truncs=0, truncs2=0;
double	nlost=0, nShadow=0, hcmp=0, ngrabs=0;
long	Fa=0, Fh=0, Zh=0, Zn=0;
long	PUT=0, PROBE=0, ZAPS=0;
long	Ccheck=0, Cholds=0;
int	mask, a_cycles=0, upto=1, strict=0;
int	state_tables=0, fairness=0, no_rck=0, Nr_Trails=0;
#ifndef INLINE
int	TstOnly=0;
#endif
#ifdef BITSTATE
int	ssize=22;
#else
int	ssize=18;
#endif
int	hmax=0, svmax=0, smax=0;
int	Maxbody=0;
uchar	*noptr;	/* used by macro Pptr(x) */
State	A_Root;		/* root of acceptance cycles */
State	now;		/* the full state vector */
#ifdef VAR_RANGES
void logval(char *, int);
void dumpranges(void);
#endif
#ifndef NOCOMP
State	comp_now;	/* compressed state vector */
State	comp_msk;
uchar	*Mask = (uchar *) &comp_msk;
#endif
Stack	*stack; 	/* for queues, processes */
Svtack	*svtack;	/* for old state vectors */
int	J1, J2, j1, j2, j3, j4;
int	A_depth = 0, depth = 0;
uchar	warned = 0, iterative = 0, every_error = 0;
#if SYNC
#define IfNotBlocked	if (boq != -1) continue;
#define UnBlock     	boq = -1
#else
#define IfNotBlocked	/* cannot block */
#define UnBlock     	/* don't bother */
#endif

void active_procs(void);
void cleanup(void);
void do_the_search(void);
void find_shorter(int);
void iniglobals(void);
void wrapup(int);
#ifndef NOBOUNDCHECK
#define Index(x, y)	Boundcheck(x, y, II, tt, t)
#else
#define Index(x, y)	x
#endif
short Air[] = {  Air0, Air1, Air2, Air3, Air4, Air5, Air6, Air7 };
char *procname[] = {
   "macuser",
   "macuser1",
   "llc",
   "applicant",
   "registrar",
   "leaveallpro",
   ":init:",
   ":np_:",
};

int
addproc(int n, int par0)
{	int k, j, h = now._nr_pr;
	uchar *o_this = this;

#ifndef INLINE
	if (TstOnly) return (h < MAXPROC);
#endif
#ifndef NOBOUNDCHECK
/* redefine Index only within this procedure */
#undef Index
#define Index(x, y)	Boundcheck(x, y, 0, 0, 0)
#endif
	if (h >= MAXPROC)
		Uerror("too many processes");
	switch (n) {
	case 0: j = sizeof(P0); break;
	case 1: j = sizeof(P1); break;
	case 2: j = sizeof(P2); break;
	case 3: j = sizeof(P3); break;
	case 4: j = sizeof(P4); break;
	case 5: j = sizeof(P5); break;
	case 6: j = sizeof(P6); break;
	case 7: j = sizeof(P7); break;
	default: Uerror("bad proc - addproc");
	}
	if (vsize%WS)
		proc_skip[h] = WS-(vsize%WS);
	else
		proc_skip[h] = 0;
#ifndef NOCOMP
	for (k = vsize + proc_skip[h]; k > vsize; k--)
		Mask[k-1] = 1; /* align */
#endif
	vsize += proc_skip[h];
	proc_offset[h] = vsize;
	now._nr_pr += 1;
	if (fairness && ((int) now._nr_pr >= (8*NFAIR)/2))
	{	printf("Error: too many processes -- current");
		printf(" max is %d procs (-DNFAIR=%d)\n",
			(8*NFAIR)/2 - 1, NFAIR);
		printf("\trecompile with -DNFAIR=%d\n",
			NFAIR+1);
		exit(1);
	}
	vsize += j;
#ifndef NOVSZ
	now._vsz = vsize;
#endif
#ifndef NOCOMP
	for (k = 1; k <= Air[n]; k++)
		Mask[vsize - k] = 1; /* pad */
	Mask[vsize-j] = 1; /* _pid */
#endif
	hmax = max(hmax, vsize);
	if (vsize >= VECTORSZ)
		Uerror("VECTORSZ is too small, edit pan.h");
	memset((char *)pptr(h), 0, j);
	this = pptr(h);
	if (BASE > 0 && h > 0)
		((P0 *)this)->_pid = h-BASE;
	else
		((P0 *)this)->_pid = h;
	switch (n) {
	case 7:	/* np_ */
		((P7 *)pptr(h))->_t = 7;
		((P7 *)pptr(h))->_p = 0;
		reached7[0]=1;
		accpstate[7][1]=1;
		break;
	case 6:	/* :init: */
		((P6 *)pptr(h))->_t = 6;
		((P6 *)pptr(h))->_p = 8; reached6[8]=1;
		/* locals: */
		/* params: */
		break;
	case 5:	/* leaveallpro */
		((P5 *)pptr(h))->_t = 5;
		((P5 *)pptr(h))->_p = 1; reached5[1]=1;
		/* locals: */
		/* params: */
		((P5 *)pptr(h))->n = par0;
#ifdef VAR_RANGES
		logval("leaveallpro:leavealltimer", ((P5 *)pptr(h))->leavealltimer);
		logval("leaveallpro:n", ((P5 *)pptr(h))->n);
		logval("leaveallpro:type", ((P5 *)pptr(h))->type);
		logval("leaveallpro:state", ((P5 *)pptr(h))->state);
#endif
		break;
	case 4:	/* registrar */
		((P4 *)pptr(h))->_t = 4;
		((P4 *)pptr(h))->_p = 1; reached4[1]=1;
		/* locals: */
		/* params: */
		((P4 *)pptr(h))->n = par0;
#ifdef VAR_RANGES
		logval("registrar:leavetimer", ((P4 *)pptr(h))->leavetimer);
		logval("registrar:member_exist", ((P4 *)pptr(h))->member_exist);
		logval("registrar:n", ((P4 *)pptr(h))->n);
		logval("registrar:type", ((P4 *)pptr(h))->type);
		logval("registrar:state", ((P4 *)pptr(h))->state);
#endif
		break;
	case 3:	/* applicant */
		((P3 *)pptr(h))->_t = 3;
		((P3 *)pptr(h))->_p = 1; reached3[1]=1;
		/* locals: */
		/* params: */
		((P3 *)pptr(h))->n = par0;
#ifdef VAR_RANGES
		logval("applicant:jointimer", ((P3 *)pptr(h))->jointimer);
		logval("applicant:n", ((P3 *)pptr(h))->n);
		logval("applicant:type", ((P3 *)pptr(h))->type);
		logval("applicant:state", ((P3 *)pptr(h))->state);
#endif
		break;
	case 2:	/* llc */
		((P2 *)pptr(h))->_t = 2;
		((P2 *)pptr(h))->_p = 37; reached2[37]=1;
		/* locals: */
		/* params: */
#ifdef VAR_RANGES
		logval("llc:type", ((P2 *)pptr(h))->type);
#endif
		break;
	case 1:	/* macuser1 */
		((P1 *)pptr(h))->_t = 1;
		((P1 *)pptr(h))->_p = 4; reached1[4]=1;
		/* locals: */
		/* params: */
		((P1 *)pptr(h))->n = par0;
#ifdef VAR_RANGES
		logval("macuser1:n", ((P1 *)pptr(h))->n);
#endif
		break;
	case 0:	/* macuser */
		((P0 *)pptr(h))->_t = 0;
		((P0 *)pptr(h))->_p = 4; reached0[4]=1;
		/* locals: */
		/* params: */
		((P0 *)pptr(h))->n = par0;
#ifdef VAR_RANGES
		logval("macuser:n", ((P0 *)pptr(h))->n);
#endif
		break;
	}
	this = o_this;
	return h-BASE;
#ifndef NOBOUNDCHECK
#undef Index
#define Index(x, y)	Boundcheck(x, y, II, tt, t)
#endif
}

#ifndef BITSTATE
#ifdef COLLAPSE
unsigned
col_p(int i)
{	int j; unsigned ordinal(char *, int);
	P0 *ptr = (P0 *) pptr(i);
	switch (ptr->_t) {
	case 0: j = sizeof(P0); break;
	case 1: j = sizeof(P1); break;
	case 2: j = sizeof(P2); break;
	case 3: j = sizeof(P3); break;
	case 4: j = sizeof(P4); break;
	case 5: j = sizeof(P5); break;
	case 6: j = sizeof(P6); break;
	case 7: j = sizeof(P7); break;
	default: Uerror("bad type - collapse");
	}
	return ordinal((char *)ptr, j);
}
#endif
#endif
void
run(void)
{	int i;
	memset((char *)&now, 0, sizeof(State));
	vsize = sizeof(State) - VECTORSZ;
#ifndef NOVSZ
	now._vsz = vsize;
#endif
	settable();
	Maxbody = max(Maxbody, sizeof(P0));
	Maxbody = max(Maxbody, sizeof(P1));
	Maxbody = max(Maxbody, sizeof(P2));
	Maxbody = max(Maxbody, sizeof(P3));
	Maxbody = max(Maxbody, sizeof(P4));
	Maxbody = max(Maxbody, sizeof(P5));
	Maxbody = max(Maxbody, sizeof(P6));
	Maxbody = max(Maxbody, sizeof(P7));
	reached[0] = reached0;
	reached[1] = reached1;
	reached[2] = reached2;
	reached[3] = reached3;
	reached[4] = reached4;
	reached[5] = reached5;
	reached[6] = reached6;
	reached[7] = reached7;
	accpstate[0] = (uchar *) emalloc(nstates0);
	accpstate[1] = (uchar *) emalloc(nstates1);
	accpstate[2] = (uchar *) emalloc(nstates2);
	accpstate[3] = (uchar *) emalloc(nstates3);
	accpstate[4] = (uchar *) emalloc(nstates4);
	accpstate[5] = (uchar *) emalloc(nstates5);
	accpstate[6] = (uchar *) emalloc(nstates6);
	accpstate[7] = (uchar *) emalloc(nstates7);
	progstate[0] = (uchar *) emalloc(nstates0);
	progstate[1] = (uchar *) emalloc(nstates1);
	progstate[2] = (uchar *) emalloc(nstates2);
	progstate[3] = (uchar *) emalloc(nstates3);
	progstate[4] = (uchar *) emalloc(nstates4);
	progstate[5] = (uchar *) emalloc(nstates5);
	progstate[6] = (uchar *) emalloc(nstates6);
	progstate[7] = (uchar *) emalloc(nstates7);
	stopstate[0] = (uchar *) emalloc(nstates0);
	stopstate[1] = (uchar *) emalloc(nstates1);
	stopstate[2] = (uchar *) emalloc(nstates2);
	stopstate[3] = (uchar *) emalloc(nstates3);
	stopstate[4] = (uchar *) emalloc(nstates4);
	stopstate[5] = (uchar *) emalloc(nstates5);
	stopstate[6] = (uchar *) emalloc(nstates6);
	stopstate[7] = (uchar *) emalloc(nstates7);
	stopstate[0][endstate0] = 1;
	stopstate[1][endstate1] = 1;
	stopstate[2][endstate2] = 1;
	stopstate[3][endstate3] = 1;
	stopstate[4][endstate4] = 1;
	stopstate[5][endstate5] = 1;
	stopstate[6][endstate6] = 1;
	stopstate[7][endstate7] = 1;
	progstate[5][4] = 1;
	stopstate[4][46] = 1;
	stopstate[3][79] = 1;
	stopstate[2][37] = 1;
	progstate[0][4] = 1;
	retrans(0, nstates0, start0, src_ln0, reached0);
	retrans(1, nstates1, start1, src_ln1, reached1);
	retrans(2, nstates2, start2, src_ln2, reached2);
	retrans(3, nstates3, start3, src_ln3, reached3);
	retrans(4, nstates4, start4, src_ln4, reached4);
	retrans(5, nstates5, start5, src_ln5, reached5);
	retrans(6, nstates6, start6, src_ln6, reached6);
	if (state_tables)
	{ printf("\nTransition Type: ");
	  printf("A=atomic; D=d_step; L=local; G=global\n");
	  printf("Source-State Labels: ");
	  printf("p=progress; e=end; a=accept;\n");
	  exit(0);
	}
	iniglobals();
#if defined(VERI) && defined(PARTIAL) && !defined(NP)
	if (!state_tables)
	{ printf("warning: for p.o. reduction to be valid ");
	  printf("the never claim must be stutter-closed\n");
	  printf("(never claims generated from LTL ");
	  printf("formulae are stutter-closed)\n");
	}
#endif
	UnBlock;	/* disable rendez-vous */
#ifdef BITSTATE
	SS = (uchar *) emalloc(1<<(ssize-3));
#else
	hinit();
#endif
#if defined(FULLSTACK) && defined(BITSTATE)
	onstack_init();
#endif
#ifdef CNTRSTACK
	LL = (uchar *) emalloc(1<<(ssize-3));
#endif
	stack	= ( Stack *) emalloc(sizeof(Stack));
	svtack	= (Svtack *) emalloc(sizeof(Svtack));
	/* a place to point for Pptr of non-running procs: */
	noptr	= (uchar *) emalloc(Maxbody * sizeof(char));
#ifdef VERI
	Addproc(VERI);	/* never - pid = 0 */
#endif
	active_procs();	/* started after never */
go_again:
	do_the_search();
#if defined(BITSTATE)
	if (--Nrun > 0 && HASH_CONST[++HASH_NR])
	{	printf("Run %d:\n", HASH_NR);
		wrap_stats();
		printf("\n");
		memset(SS, 0, 1<<(ssize-3));
#if defined(CNTRSTACK)
		memset(LL, 0, 1<<(ssize-3));
#endif
#if defined(FULLSTACK)
		memset((uchar *) S_tab, 0, 
		(1<<(ssize-3))*sizeof(struct H_el *));
#endif
		nstates=nlinks=truncs=truncs2=ngrabs = 0;
		nlost=nShadow=hcmp = 0;
		Fa=Fh=Zh=Zn = 0;
		PUT=PROBE=ZAPS=Ccheck=Cholds = 0;
		goto go_again;
	}
#endif
}
#include <stdarg.h>
void
Printf(const char *fmt, ...)
{	/* Make sure the args to Printf
	 * are always evaluated (e.g., they
	 * could contain a run stmnt)
	 * but don't generate the output
	 * during verification runs
	 * unless explicitly wanted
	 * If this fails on your system
	 * compile SPIN itself -DPRINTF
	 * and this code is not generated
	 */
#ifdef PRINTF
	va_list args;
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
#endif
}
#if !defined(SAFETY) && !defined(BITSTATE)
int
depth_of(struct H_el *s)
{	Trail *t; int d;
	for (d = 0; d <= A_depth; d++)
	{	t = &trail[d];
		if (s == t->ostate)
			return d;
	}
	printf("pan: cannot happen, depth_of\n");
	return depthfound;
}
#endif
void
do_the_search(void)
{	int i;
	depth=mreached=0;
	trpt = &trail[depth];
#ifdef VERI
	trpt->tau |= 4;	/* the claim moves first */
#endif
	for (i = 0; i < (int) now._nr_pr; i++)
	{	P0 *ptr = (P0 *) pptr(i);
#ifndef NP
		if (!(trpt->o_pm&2)
		&&  accpstate[ptr->_t][ptr->_p])
		{	trpt->o_pm |= 2;
		}
#endif
		if (!(trpt->o_pm&4)
		&&  progstate[ptr->_t][ptr->_p])
		{	trpt->o_pm |= 4;
	}	}
#ifndef NOCOMP
	Mask[0] = Mask[1] = 1;	/* _nr_pr, _nr_qs */
	if (!a_cycles)
	{	i = &(now._a_t) - (unsigned char *) &now;
		Mask[i] = 1; /* _a_t */
	}
#ifndef NOFAIR
	if (!fairness)
	{	int j = 0;
		i = &(now._cnt[0]) - (unsigned char *) &now;
		while (j++ < NFAIR)
			Mask[i++] = 1; /* _cnt[] */
	}
#endif
#endif
#ifndef NOFAIR
	if (fairness
	&&  (a_cycles && (trpt->o_pm&2)))
	{	now._a_t = 2;	/* set the A-bit */
		now._cnt[0] = now._nr_pr;
#ifdef VERBOSE
	printf("%3d: fairness Rule 1, cnt=%d, _a_t=%d\n",
		depth, now._cnt[now._a_t&1], now._a_t);
#endif
	}
#endif
	new_state();	/* start 1st DFS */
}
#ifndef INLINE
char
do_transit(Trans *t, short II, int n)
{	char m;
	short tt = (short) ((P0 *)this)->_p;
#define continue	return 0
#include "pan.m"
P999:	return m;
#undef continue
}
int
enabled(int iam, int pid)
{	Trans *t; uchar *othis = this;
	int res = 0; short tt; char ot;
#ifdef VERI
	if (pid > 0) pid++;
#endif
	if (pid == iam)
		Uerror("used: enabled(pid=thisproc)");
	if (pid < 0 || pid >= (int) now._nr_pr)
		return 0;
	this = pptr(pid);
	TstOnly = 1;
	tt = (short) ((P0 *)this)->_p;
	ot = (uchar) ((P0 *)this)->_t;
	for (t = trans[ot][tt]; t; t = t->nxt)
		if (do_transit(t, pid, 0))
		{	res = 1;
			break;
		}
	TstOnly = 0;
	this = othis;
	return res;
}
#endif
void
new_state(void)
{	register Trans *t;
	char n, m, ot, kk;
	short II, JJ=0, tt;

	short From = now._nr_pr-1, To = BASE;
Down:
#ifdef CHECK
	printf("%d: Down - %s",
		depth, (trpt->tau&4)?"claim":"program");
	printf(" %saccepting [pids %d-%d]\n",
		(trpt->o_pm&2)?"":"non-", From, To);
#endif
	trpt->tau &= ~(16|32|64); /* make sure these are off */
	if (depth >= maxdepth)
	{	truncs++;
#if SYNC
		(trpt+1)->o_n = 1; /* not a deadlock */
#endif
		if (!warned)
		{ warned = 1;
		  printf("error: max search depth too small\n");
		}
		(trpt-1)->tau |= 16; /* worstcase guess */
		goto Up;
	}
AllOver:
#if defined(FULLSTACK)
	trpt->ostate = (struct H_el *) 0;
#endif
#ifdef VERI
	if ((trpt->tau&4) || ((trpt-1)->tau&128))
#endif
	if (boq == -1) {	/* if not mid-rv */
#ifndef SAFETY
		/* this check should now be redundant
		 * because the seed state also appears
		 * on the 1st dfs stack and would be
		 * matched in hstore below
		 */
		if ((now._a_t&1) && depth > A_depth)
		{	if (!memcmp((char *)&A_Root, 
				(char *)&now, vsize))
			{
				depthfound = A_depth;
#ifdef CHECK
			  printf("matches seed\n");
#endif
#ifdef NP
			  uerror("non-progress cycle");
#else
			  uerror("acceptance cycle");
#endif
			  goto Up;
			}
#ifdef CHECK
			printf("not seed\n");
#endif
		}
#endif
		if (!(trpt->tau&8)) /* if no atomic move */
		{
#ifdef CNTRSTACK
			d_hash((uchar *)&now, vsize);
			trpt->j6 = j1; trpt->j7 = j2;
			JJ = LL[j1] && LL[j2];
#endif
#ifdef FULLSTACK
#ifdef BITSTATE
			JJ = onstack_now();
#else
			II = hstore((char *)&now, vsize, 1);
			JJ = (II == 2)?1:0;
#endif
#endif
#ifdef BITSTATE
#ifndef CNTRSTACK
			d_hash((uchar *) &now, vsize);
#endif
			kk = II = ((SS[j2]&j3) && (SS[j1]&j4));
#ifdef DEBUG
			if (II) printf("Old bitstate\n");
			else printf("New bitstate\n");
#endif
#else
#ifndef FULLSTACK
			II = hstore((char *)&now, vsize, 2);
#endif
			kk = (II == 1 || II == 2);
#endif
#ifndef SAFETY
#if defined(FULLSTACK) && defined(BITSTATE)
			if (!JJ && (now._a_t&1) && depth > A_depth)
			{	int oj1 = j1;
				uchar o_a_t = now._a_t;
				now._a_t &= ~(1|16|32);
				if (onstack_now())
				{	II = 3;
#ifdef VERBOSE
	printf("state match on 1st dfs stack\n");
#endif
				}
				now._a_t = o_a_t;
				j1 = oj1;
			}
#endif
			if (II == 3 && a_cycles && (now._a_t&1))
			{
#ifndef NOFAIR
			   if (fairness && now._cnt[1] != 0)
			   {
#ifdef VERBOSE
	printf("	fairness count non-zero\n");
#endif
				II = 0;
			   } else
#endif
			   {
#ifdef BITSTATE
				depthfound = Lstate->tagged - 1;
#ifdef NP
				uerror("non-progress cycle");
#else
				uerror("acceptance cycle");
#endif
#else
				depthfound = depth_of(Lstate);
#ifdef NP
				uerror("non-progress cycle");
#else
				uerror("acceptance cycle");
#endif
				nShadow--;
#endif
				goto Up;
			   }
			}
#endif
#if !defined(FULLSTACK) && !defined(CNTRSTACK) && defined(BITSTATE)
#ifdef PARTIAL
			JJ = II; /* worstcase guess for p.o. */
#endif
#endif
#ifdef PARTIAL
#ifndef SAFETY
			if ((II && JJ) || (II == 3))
			{	/* marker for liveness proviso */
				truncs2++;
				(trpt-1)->tau |= 16;
			}
#else
			if (!II || !JJ)
			{	/* has successor outside stack */
				(trpt-1)->tau |= 64;
			}
#endif
#endif
			if (II)
			{	truncs++;
				goto Up;
			}
			if (!kk) nstates++;
#ifdef BITSTATE
			SS[j2] |= j3; SS[j1] |= j4;
#endif
#if defined(FULLSTACK) || defined(CNTRSTACK)
			onstack_put();
#ifdef DEBUG
#ifdef FULLSTACK
		printf("%d: putting %u (%d)\n", depth,
			trpt->ostate, 
			(trpt->ostate)?trpt->ostate->tagged:0);
#else
		printf("%d: putting\n", depth);
#endif
#endif
#endif
	}	}
	if (depth > mreached)
		mreached = depth;
#ifdef VERI
	if (trpt->tau&4)
#endif
	trpt->tau &= ~(1|2);	/* timeout and -request off */
	n = 0;
#if SYNC
	(trpt+1)->o_n = 0;
#endif
#ifdef VERI
	if (now._nr_pr == 0	/* claim terminated */
	|| ((P0 *)pptr(0))->_p == endclaim)
		uerror("claim violated!");
	if (stopstate[VERI][((P0 *)pptr(0))->_p])
		uerror("endstate in claim reached");
Stutter:
	if (trpt->tau&4)	/* must make a claimmove */
	{	II = 0;		/* never */
		goto Veri0;
	}
#endif
#ifdef PARTIAL
	/* Look for a process with only safe transitions */
	/* (special rules apply in the 2nd dfs) */
#ifdef SAFETY
	if (boq == -1 && From != To)
#else
/* implied: #ifdef FULLSTACK */
	if (boq == -1 && From != To
	&&  (!(now._a_t&1)
	    ||	(a_cycles &&
#ifndef BITSTATE
#ifdef VERI
		 (trpt-1)->ostate &&
		!(((char *)&((trpt-1)->ostate->state))[0] & 128))
#else
		!(((char *)&(trpt->ostate->state))[0] & 128))
#endif
#else
#ifdef VERI
		(trpt-1)->ostate &&
		(trpt-1)->ostate->proviso == 0)
#else
		trpt->ostate->proviso == 0)
#endif
#endif
	   ))
/* #endif */
#endif
	for (II = From; II >= To; II -= 1)
	{
Resume:	/* pick up here if preselect fails */
		this = pptr(II);
		tt = (short) ((P0 *)this)->_p;
		ot = (uchar) ((P0 *)this)->_t;
		if (trans[ot][tt]->atom & 8)
		{
			t = trans[ot][tt];
			if (t->qu[0] != 0)
#ifndef NOCOND
			{	Ccheck++;
				if (!q_cond(t))
					continue;
				Cholds++;
			}
#else
				continue;
#endif
			From = To = II;
#ifdef NIBIS
			t->om = 0;
#endif
			trpt->tau |= 32; /* preselect marker */
#ifdef DEBUG
#ifdef NIBIS
			printf("%3d: proc %d Pre", depth, II);
			printf("Selected (om=%d, tau=%d)\n", 
				t->om, trpt->tau);
#else
	printf("%3d: proc %d PreSelected (tau=%d)\n", 
		depth, II, trpt->tau);
#endif
#endif
			goto Again;
		}
	}
	trpt->tau &= ~32;
#endif
Again:
	/* The Main Expansion Loop over Processes */
	trpt->o_pm &= ~(8|16|32|64); /* fairness-marks */
#ifndef NOFAIR
	if (fairness && boq == -1
#ifdef VERI
	&& (!(trpt->tau&4) && !((trpt-1)->tau&128))
#endif
	&& !(trpt->tau&8))
	{	/* A_bit = 1; Cnt = N in acc states with A_bit 0 */
		if (!(now._a_t&2))
		{
			if (a_cycles && (trpt->o_pm&2))
			{	/* Accepting state */
				now._a_t |= 2;
				now._cnt[now._a_t&1] = now._nr_pr;
				trpt->o_pm |= 8;
#ifdef DEBUG
	printf("%3d: fairness Rule 1: cnt=%d, _a_t=%d\n",
			depth, now._cnt[now._a_t&1], now._a_t);
#endif
			}
		} else
		{	/* A_bit = 0 when Cnt 0 */
			if (now._cnt[now._a_t&1] == 0)
			{	now._a_t &= ~2;
				trpt->o_pm |= 16;
#ifdef DEBUG
	printf("%3d: fairness Rule 3: _a_t = %d\n",
		depth, now._a_t);
#endif
	}	}	}
#endif
	for (II = From; II >= To; II -= 1)
	{
#if SYNC
		/* no rendezvous with same proc */
		if (boq != -1 && trpt->pr == II) continue;
#endif
Veri0:		this = pptr(II);
		tt = (short) ((P0 *)this)->_p;
		ot = (uchar) ((P0 *)this)->_t;
#ifdef NIBIS
		/* don't repeat a previous preselected expansion */
		/* could hit this if reduction proviso was false */
		t = trans[ot][tt];
		if (!(trpt->tau&4)
		&& !(trpt->tau&1)
		&& !(trpt->tau&32)
		&& (t->atom & 8)
		&& boq == -1
		&& From != To)
		{	if (t->qu[0] == 0
			||  q_cond(t))
			{	m = t->om;
				if (m>n||(n>3&&m!=0)) n=m;
				continue; /* did it before */
		}	}
#endif
		trpt->o_pm &=  ~1; /* no move in this pid yet */
		/* Fairness: Cnt++ when Cnt == II */
#ifndef NOFAIR
		trpt->o_pm &= ~64; /* didn't apply rule 2 */
		if (fairness
		&& !(trpt->o_pm&32)
		&& (now._a_t&2)
		&&  now._cnt[now._a_t&1] == II+1)
		{	now._cnt[now._a_t&1] -= 1;
#ifdef VERI
			/* claim need not participate */
			if (now._cnt[now._a_t&1] == 1)
				now._cnt[now._a_t&1] = 0;
#endif
#ifdef DEBUG
		printf("%3d: proc %d fairness ", depth, II);
		printf("Rule 2: --cnt to %d (%d)\n",
			now._cnt[now._a_t&1], now._a_t);
#endif
			trpt->o_pm |= (32|64);
		}
#endif
#ifdef HAS_PROVIDED
		if (!provided(II, ot, tt, t)) continue;
#endif
		/* check all trans of proc II - escapes first */
#ifdef HAS_UNLESS
		trpt->e_state = 0;
#endif
		for (t = trans[ot][tt]; t; t = t->nxt)
		{
#ifdef HAS_UNLESS
			/* exploring all transitions from
			 * a single escape state suffices
			 */
			if (trpt->e_state > 0
			&&  trpt->e_state != t->e_trans)
			{
#ifdef DEBUG
		printf("skip 2nd escape %d (did %d before)\n",
			t->e_trans, trpt->e_state);
#endif
				break;
			}
#endif
#ifdef INLINE
#include "pan.m"
#else
			if (!(m = do_transit(t, II, n))) continue;
#endif
P999:			/* jumps here when move succeeds */
			if (boq == -1)
#ifdef PELED
			{	if ((trpt->tau&32) && (trpt->o_pm&1))
					trpt->tau |= 16;
				trpt->o_pm |= 1; /* we moved */
			}
#else
				trpt->o_pm |= 1; /* we moved */
#endif
#ifdef PEG
			peg[t->forw]++;
#endif
#if defined(VERBOSE) || defined(CHECK)
			printf("%3d: proc %d exec %d, ", 
				depth, II, t->forw);
			printf("%d to %d, %s %s %s", 
				tt, t->st, t->tp,
				(t->atom&2)?"atomic":"",
				(boq != -1)?"rendez-vous":"");
#ifdef HAS_UNLESS
	if (t->e_trans)
		printf(" (escapes to state %d)", t->st);
#endif
	printf(" %saccepting [tau=%d]\n",
		(trpt->o_pm&2)?"":"non-", trpt->tau);
#endif
#ifdef HAS_LAST
#ifdef VERI
			if (II != 0) now._last = II + 1 - BASE;
#else
			now._last = II + 1;
#endif
#endif
#ifdef HAS_UNLESS
			trpt->e_state = t->e_trans;
#endif
			depth++; trpt++;
			trpt->pr = II;
			trpt->st = tt;
			trpt->o_pm &= ~(2|4);
			if (t->st > 0)
			{	((P0 *)this)->_p = t->st;
/*	moved down		reached[ot][t->st] = 1; */
			}
#ifndef SAFETY
			if (a_cycles)
			{	register int ii;
#define PQ	((P0 *)pptr(ii))
#if ACCEPT_LAB>0
#ifdef NP
				/* state 1 of np_ claim */
				if (((P0 *)pptr(0))->_p == 1)
					trpt->o_pm |= 2;
#else
				for (ii = 0; ii < (int) now._nr_pr; ii++)
				{ if (accpstate[PQ->_t][PQ->_p])
				  {	trpt->o_pm |= 2;
					break;
			   	} }
#endif
#endif
#if defined(HAS_NP) && PROG_LAB>0
				for (ii = 0; ii < (int) now._nr_pr; ii++)
				{ if (progstate[PQ->_t][PQ->_p])
				  {	trpt->o_pm |= 4;
					break;
			   	} }
#endif
#undef PQ
			}
#endif
			trpt->o_t  =  t; trpt->o_n  = n;
			trpt->o_ot = ot; trpt->o_tt = tt;
			trpt->o_To = To; trpt->o_m  = m;
			trpt->tau = 0;
			if (boq != -1 || (t->atom&2))
			{	trpt->tau |= 8;
#ifdef VERI
				/* atomic sequence in claim */
				if((trpt-1)->tau&4)
					trpt->tau |= 4;
				else
					trpt->tau &= ~4;
			} else
			{	if ((trpt-1)->tau&4)
					trpt->tau &= ~4;
				else
					trpt->tau |= 4;
			}
			/* if claim allowed timeout, so
			/* does the next program-step: */
			if (((trpt-1)->tau&1) && !(trpt->tau&4))
				trpt->tau |= 1;
#else
			} else
				trpt->tau &= ~8;
#endif
			if (boq == -1 && (t->atom&2))
			{	From = To = II; nlinks++;
			} else
			{	From = now._nr_pr-1; To = BASE;
			}
			goto Down;	/* pseudo-recursion */
Up:
#ifdef CHECK
	printf("%d: Up - %s\n", depth,
		(trpt->tau&4)?"claim":"program");
#endif
#ifndef NOFAIR
			if (trpt->o_pm&128)	/* fairness alg */
			{	now._cnt[now._a_t&1] = trpt->oval;
				n = 1; trpt->o_pm &= ~128;
				depth--; trpt--;
#if defined(VERBOSE) || defined(CHECK)
	printf("%3d: reversed fairness default move\n", depth);
#endif
				goto Q999;
			}
#endif
#ifdef HAS_LAST
#ifdef VERI
			if (trpt->pr != 0)
			{	if (depth <= 4)
				 now._last = 0;
				else
				 now._last = (trpt-4)->pr + 1-BASE;
			}
#else
			now._last = (depth<2)?0:(trpt-2)->pr + 1;
#endif
#endif
#ifndef SAFETY
			if ((now._a_t&1) && depth <= A_depth)
				return;	/* to checkcycles() */
#endif
			t  = trpt->o_t;  n  = trpt->o_n;
			ot = trpt->o_ot; II = trpt->pr;
			tt = trpt->o_tt; this = pptr(II);
			To = trpt->o_To; m  = trpt->o_m;
#include "pan.b"
R999:			/* jumps here when done */
#ifdef VERBOSE
			printf("%3d: proc %d ", depth, II);
			printf("reverses %d, %d to %d,",
				t->forw, tt, t->st);
			printf(" %s [abit=%d,adepth=%d,", 
				t->tp, now._a_t, A_depth);
			printf("tau=%d,%d]\n", 
				trpt->tau, (trpt-1)->tau);
#endif
#ifdef PARTIAL
			/* pass the proviso tags */
			if ((trpt->tau&8)	/* rv or atomic */
			&&  (trpt->tau&16))
				(trpt-1)->tau |= 16;
#ifdef SAFETY
			if ((trpt->tau&8)	/* rv or atomic */
			&&  (trpt->tau&64))
				(trpt-1)->tau |= 64;
#endif
#endif
			depth--; trpt--;
#ifdef NIBIS
			(trans[ot][tt])->om = m; /* head of list */
#endif
			/* i.e., not set if rv fails */
			if (m) reached[ot][t->st] = 1;
			if (m>n||(n>3&&m!=0)) n=m;
			((P0 *)this)->_p = tt;
		} /* all options */
#ifndef NOFAIR
		/* Fairness: undo Rule 2 */
		if ((trpt->o_pm&32)
		&&  (trpt->o_pm&64))
		{	if (trpt->o_pm&1)
			{
#ifdef VERI
				if (now._cnt[now._a_t&1] == 0)
					now._cnt[now._a_t&1] = 1;
#endif
				now._cnt[now._a_t&1] += 1;
#ifdef VERBOSE
		printf("%3d: proc %d fairness ", depth, II);
		printf("undo Rule 2, cnt=%d, _a_t=%d\n",
			now._cnt[now._a_t&1], now._a_t);
#endif
				trpt->o_pm &= ~(32|64);
			} else
			{	if (n > 0)
				{
					trpt->o_pm &= ~64;
					II = From+1;
		}	}	}
#endif
#ifdef VERI
		if (II == 0) break;	/* never claim */
#endif
	} /* all processes */
#ifndef NOFAIR
	/* Fairness: undo Rule 2 */
	if (trpt->o_pm&32)	/* remains if proc blocked */
	{
#ifdef VERI
		if (now._cnt[now._a_t&1] == 0)
			now._cnt[now._a_t&1] = 1;
#endif
		now._cnt[now._a_t&1] += 1;
#ifdef VERBOSE
		printf("%3d: proc -- fairness ", depth);
		printf("undo Rule 2, cnt=%d, _a_t=%d\n",
			now._cnt[now._a_t&1], now._a_t);
#endif
		trpt->o_pm &= ~32;
	}
	if (fairness
	&&  n == 0		/* nobody moved */
#ifdef VERI
	&& !(trpt->tau&4)	/* in program move */
#endif
	&& !(trpt->tau&8)	/* not an atomic one */
#ifdef OTIM
	&& ((trpt->tau&1) || endstate())
#else
#ifdef ETIM
	&&  (trpt->tau&1)	/* already tried timeout */
#endif
#endif
#ifdef PARTIAL
	/* see below  */
	&& !((trpt->tau&32) && (n == 0 || (trpt->tau&16)))
#endif
	&& now._cnt[now._a_t&1] > 0)	/* needed more procs */
	{	depth++; trpt++;
		trpt->o_pm |= 128 | ((trpt-1)->o_pm&(2|4));
		trpt->oval = now._cnt[now._a_t&1];
		now._cnt[now._a_t&1] = 0;
#ifdef VERI
		trpt->tau = 4;
#else
		trpt->tau = 0;
#endif
		From = now._nr_pr-1; To = BASE;
#if defined(VERBOSE) || defined(CHECK)
		printf("%3d: fairness default move ", depth);
		printf("(all procs block)\n");
#endif
		goto Down;
	}
Q999:	/* returns here with n>0 when done */;
	if (trpt->o_pm&8)
	{	now._a_t &= ~2;
		now._cnt[now._a_t&1] = 0;
		trpt->o_pm &= ~8;
#ifdef VERBOSE
		printf("%3d: fairness undo Rule 1, _a_t=%d\n",
			depth, now._a_t);
#endif
	}
	if (trpt->o_pm&16)
	{	now._a_t |= 2;
		trpt->o_pm &= ~16;
#ifdef VERBOSE
		printf("%3d: fairness undo Rule 3, _a_t=%d\n",
			depth, now._a_t);
#endif
	}
#endif
#ifdef PARTIAL
#ifdef SAFETY
	/* preselected move - no successors outside stack */
	if ((trpt->tau&32) && !(trpt->tau&64))
	{	From = now._nr_pr-1; To = BASE;
#ifdef DEBUG
	printf("%3d: proc %d UnSelected (n=%d, tau=%d)\n", 
	depth, II+1, n, trpt->tau);
#endif
		n = 0; trpt->tau &= ~(16|32|64);
		if (II >= BASE)	/* II already decremented */
			goto Resume;
		else
			goto Again;
	}
#else
	/* at least one move that was preselected at this */
	/* level, blocked or truncated at the next level  */
/* implied: #ifdef FULLSTACK */
	if ((trpt->tau&32) && (n == 0 || (trpt->tau&16)))
	{
#ifdef DEBUG
	printf("%3d: proc %d UnSelected (n=%d, tau=%d)\n", 
	depth, II+1, n, trpt->tau);
#endif
		if (a_cycles && (trpt->tau&16))
		{	if (!(now._a_t&1))
			{
#ifdef DEBUG
	printf("%3d: setting proviso bit\n", depth);
#endif
#ifndef BITSTATE
#ifdef VERI
			if ((trpt-1)->ostate)
			((char *)&((trpt-1)->ostate->state))[0] |= 128;
#else
			((char *)&(trpt->ostate->state))[0] |= 128;
#endif
#else
#ifdef VERI
			if ((trpt-1)->ostate)
			(trpt-1)->ostate->proviso = 1;
#else
			trpt->ostate->proviso = 1;
#endif
#endif
				From = now._nr_pr-1; To = BASE;
				n = 0; trpt->tau &= ~(16|32|64);
				goto Again; /* do full search */
			} /* else accept reduction */
		} else
		{	From = now._nr_pr-1; To = BASE;
			n = 0; trpt->tau &= ~(16|32|64);
			if (II >= BASE)	/* already decremented */
				goto Resume;
			else
				goto Again;
	}	}
/* #endif */
#endif
#endif
	if (n == 0 || ((trpt->tau&4) && (trpt->tau&2)))
	{
#ifdef DEBUG
	printf("%3d: no move [II=%d, tau=%d, boq=%d]\n",
		 depth, II, trpt->tau, boq);
#endif
#if SYNC
		/* ok if a rendez-vous fails: */
		if (boq != -1) goto Done;
#endif
		/* ok if no procs or we're at maxdepth */
		if (now._nr_pr == 0
#ifdef OTIM
		||  endstate()
#endif
		||  depth >= maxdepth-1) goto Done;
		if ((trpt->tau&8) && !(trpt->tau&4))
		{	trpt->tau &= ~(1|8);
			/* 1=timeout, 8=atomic */
			From = now._nr_pr-1; To = BASE;
#ifdef DEBUG
		printf("%3d: atomic step proc %d ", depth, II);
		printf("unexecutable\n");
#endif
#ifdef VERI
			trpt->tau |= 4;	/* switch to claim */
#endif
			goto AllOver;
		}
#ifdef ETIM
		if (!(trpt->tau&1)) /* didn't try timeout yet */
		{
#ifdef VERI
			if (trpt->tau&4)
			{
#ifndef NTIM
				if (trpt->tau&2) /* requested */
#endif
				{	trpt->tau |=  1;
					trpt->tau &= ~2;
#ifdef DEBUG
				printf("%d: timeout\n", depth);
#endif
					goto Stutter;
			}	}
			else
			{	/* only claim can enable timeout */
				if ((trpt->tau&8)
				&&  !((trpt-1)->tau&4))
/* blocks inside an atomic */		goto BreakOut;
#ifdef DEBUG
				printf("%d: req timeout\n",
					depth);
#endif
				(trpt-1)->tau |= 2; /* request */
				goto Up;
			}
#else
#ifdef DEBUG
			printf("%d: timeout\n", depth);
#endif
			trpt->tau |=  1;
			goto Again;
#endif
		}
#endif
BreakOut:
/* old location of atomic block code */
#ifdef VERI
#ifndef NOSTUTTER
		if ((now._a_t&1) && !(trpt->tau&4))
		{	trpt->tau |= 4;   /* claim stuttering */
			trpt->tau |= 128; /* stutter mark */
#ifdef DEBUG
			printf("%d: claim stutter\n", depth);
#endif
			goto Stutter;
		}
#endif
#else
		if (!endstate() && !a_cycles)
			uerror("invalid endstate");
#endif
	}
Done:
	if (!(trpt->tau&8))	/* not in atomic seqs */
	{
		if (n != 0
#ifdef VERI
		/* --after-- a program-step, i.e., */
		/* after backtracking a claim-step */
		&& (trpt->tau&4)
#endif
		&& !(now._a_t&1))
		{
#ifndef NOFAIR
			if (fairness)
			{
#ifdef VERBOSE
			printf("Consider check %d %d...\n",
				now._a_t, now._cnt[0]);
#endif
				if ((now._a_t&2) /* A-bit */
				&&  (now._cnt[0] == 0))
					checkcycles();
			} else
#endif
#ifndef SAFETY
			if (a_cycles && (trpt->o_pm&2))
				checkcycles();
#endif
		}
#if defined(FULLSTACK) || defined(CNTRSTACK)
#ifdef VERI
		if (boq == -1
		&&  (((trpt->tau&4) && !(trpt->tau&128))
		||  (!(trpt->tau&4) && ((trpt-1)->tau&128))))
#else
		if (boq == -1)
#endif
		{
#ifdef DEBUG
#ifdef FULLSTACK
			printf("%d: zapping %u (%d)\n",
				depth, trpt->ostate,
			(trpt->ostate)?trpt->ostate->tagged:0);
#else
			printf("%d: zapping\n", depth);
#endif
#endif
			onstack_zap();
		}
#endif
	}
	if (depth > 0) goto Up;
}

void
assert(int a, char *s, int ii, int tt, Trans *t)
{
	if (!a)
	{	char bad[250];
		sprintf(bad, "assertion violated %s", s);
		depth++; trpt++;
		if (t) {
			trpt->pr = ii;
			trpt->st = tt;
			trpt->o_t = t;
		} else {
			trpt->pr = (trpt-1)->pr;
			trpt->st = (trpt-1)->st;
			trpt->o_t = (trpt-1)->o_t;
		}
		uerror(bad);
		depth--; trpt--;
	}
}
#ifndef NOBOUNDCHECK
int
Boundcheck(int x, int y, int a1, int a2, Trans *a3)
{
	assert((x >= 0 && x < y), "- invalid array index",
		a1, a2, a3);
	return x;
}
#endif
#ifdef MEMCNT
double memcnt=0;
double memlim = (double) (1<<30);
#endif
void
wrap_stats(void)
{	double a, b;

	if (nShadow>0)
	printf("%8g states, stored (%g visited)\n",
			nstates - nShadow, nstates);
	else
	printf("%8g states, stored\n", nstates);
	printf("%8g states, matched\n", truncs);
#ifdef CHECK
	printf("%8g matches within stack\n",truncs2);
#endif
	if (nShadow>0)
	printf("%8g transitions (= visited+matched)\n",
		nstates+truncs);
	else
	printf("%8g transitions (= stored+matched)\n",
		nstates+truncs);
	printf("%8g atomic steps\n", nlinks);
	if (nlost) printf("%g lost messages\n", (double)nlost);
#ifdef BITSTATE
#ifdef CHECK
	printf("%8g states allocated for dfs stack\n", ngrabs);
#endif
	a = (double) (1<<ssize);
	b = nstates+1.;
	printf("hash factor: %g ", a/b);
	if (!single)
	{ if (a/b > 100.)
	   printf("(expected coverage: >= 99.9%% on avg.)\n");
	  else if (a/b > 10.)
	   printf("(expected coverage: >= 98%% on avg.)\n");
	  else
	   printf("(best coverage if >100)\n");
	} else
	{ if (a/b > 1000.)
	   printf("(expected coverage: >= 99.9%% on avg.)\n");
	  else if (a/b > 100.)
	   printf("(expected coverage: >= 98%% on avg.)\n");
	  else
	   printf("(best coverage (1-bit hash) if >1000)\n");
	}
#else
	printf("hash conflicts: %g (resolved)\n", hcmp);
#endif
}
void
wrapup(int arg)
{	double nr;

	signal(SIGINT, SIG_DFL);
	printf("(%s)\n", Version);
	if (!done) printf("Warning: Search not completed\n");
#ifdef PARTIAL
	printf("	+ Partial Order Reduction\n");
#endif
#ifdef CHECK
#ifdef FULLSTACK
	printf("	+ FullStack Matching\n");
#endif
#ifdef CNTRSTACK
	printf("	+ CntrStack Matching\n");
#endif
#endif
#ifdef BITSTATE
	printf("\nBit statespace search for:\n");
#else
	printf("\nFull statespace search for:\n");
#endif
#ifdef VERI
	printf("	never-claim         	+\n");
	printf("	assertion violations	+ ");
	printf("(if within scope of claim)\n");
#else
#ifdef NOCLAIM
	printf("	never-claim         	- (not selected)\n");
#else
	printf("	never-claim         	- (none specified)\n");
#endif
	printf("	assertion violations	+\n");
#endif
#ifndef SAFETY
#ifdef NP
	printf("	non-progress cycles 	");
#else
	printf("	acceptance   cycles 	");
#endif
	if (a_cycles)
		printf("+ (fairness %sabled)\n",
			fairness?"en":"dis");
	else printf("- (not selected)\n");
#else
	printf("	cycle checks       	- (disabled by -DSAFETY)\n");
#endif
#ifdef VERI
	printf("	invalid endstates	- ");
	printf("(disabled by never-claim)\n\n");
#else
	printf("	invalid endstates	+\n\n");
#endif
	printf("State-vector %d byte, depth reached %d", 
					hmax, mreached);
	printf(", errors: %d\n", errors);
	wrap_stats();
	printf("(max size 2^%d states", ssize);
#ifdef CHECK
	printf(", stackframes: %d/%d)\n\n", smax, svmax);
	printf("stats: fa %d, fh %d, zh %d, zn %d - ",
		Fa, Fh, Zh, Zn);
	printf("check %d holds %d\n", Ccheck, Cholds);
	printf("stack stats: puts %d, probes %d, zaps %d\n",
		PUT, PROBE, ZAPS);
#else
	printf(")\n\n");
#endif
#ifdef MEMCNT
#ifdef BITSTATE
	nr = (nstates-nShadow)*(double)hmax
	   + (double) (maxdepth*sizeof(Trail));
	if (memcnt < nr)
	{	printf("%8g	equivalent memory usage", nr);
		printf(" in bytes (stored*vector + stack)\n");
		printf("%8g	actual memory usage\n\n",
			memcnt);
	} else
#endif
		printf("%8g	memory usage (bytes)\n\n",
			memcnt);
#endif
	if (done && !no_rck) do_reach();
#ifdef PEG
	{ int i;
	  printf("\nPeg Counts (transitions executed):\n");
	  for (i = 1; i < NTRANS; i++)
	  {	if (peg[i]) putpeg(i, peg[i]);
	} }
#endif
#ifdef VAR_RANGES
	dumpranges();
#endif
	exit(0);
}

void
d_hash(uchar *cp, int om)
{	register int z = (int) HASH_CONST[HASH_NR];
	register int *q, *r;
	register int h;
	register m, n;

	h = (om+sizeof(int)-1)/sizeof(int);
	m = n = -1;
	q = r = (int *) cp;
	r += (int) h;
	do {
		if (m < 0)
		{	m += m;
			m ^= z;
		} else
			m += m;
		m ^= *q++;
		if (n < 0)
		{	n += n;
			n ^= z;
		} else
			n += n;
		n ^= *--r;
	} while (--h > 0);
	J1 = (m ^ (m>>(8*sizeof(int)-ssize)))&mask;
	J2 = (n ^ (n>>(8*sizeof(int)-ssize)))&mask;
	j3 = (1<<(J1&7)); j1 = J1>>3;
	j4 = (1<<(J2&7)); j2 = J2>>3;
	if (!single)
	{	j3 = (1<<(J1&7)); j2 = J2>>3;
		j4 = (1<<(J2&7)); j1 = J1>>3;
	} else /* single-bit address */
	{	J1 = J1^J2;	/* use all bits */
		j3 = (1<<(J1&7)); j2 = J1>>3;
		j1 = 0; j4 = 1;
	}
}

void
s_hash(uchar *cp, int om)
{	register int z = (int) HASH_CONST[HASH_NR];
	register int *q;
	register int h;

	register m = -1;
	h = (om+sizeof(int)-1)/sizeof(int);
	q = (int *) cp;
	do {
		if (m < 0)
		{	m += m;
			m ^= z;
		} else
			m += m;
		m ^= *q++;
	} while (--h > 0);
#ifdef BITSTATE
	if (S_tab == H_tab)
	j1 = (m^(m>>(8*sizeof(int)-(ssize-3))))&((1<<(ssize-3))-1);
	else
#endif
	j1 = (m^(m>>(8*sizeof(int)-ssize)))&mask;
}

void
main(int argc, char *argv[])
{	FILE *efd = stderr;	/* default */

#if defined(SAFETY) && defined(NP)
	fprintf(efd, "error: cannot combine -DNP and -DSAFETY\n");
	exit(1);
#endif
	while (argc > 1 && argv[1][0] == '-')
	{	switch (argv[1][1]) {
#ifndef SAFETY
#ifdef NP
		case 'a': fprintf(efd, "error: -a disabled");
			  usage(efd); break;
#else
		case 'a': a_cycles = 1; break;
#endif
#endif
		case 'c': upto  = atoi(&argv[1][2]); break;
		case 'd': state_tables++; break;
		case 'e': every_error = 1; break;
#if !defined(SAFETY) && !defined(NOFAIR)
		case 'f': fairness = 1; break;
#endif
		case 'h': HASH_NR = atoi(&argv[1][2])%3; break;
		case 'I': iterative = 2; every_error = 1; break;
		case 'i': iterative = 1; every_error = 1; break;
#ifndef SAFETY
#ifdef NP
		case 'l': a_cycles = 1; break;
#else
		case 'l': fprintf(efd, "error: -l disabled");
			  usage(efd); break;
#endif
#endif
		case 'm': maxdepth = atoi(&argv[1][2]); break;
		case 'n': no_rck = 1; break;
		case 'q': strict = 1; break;
		case 'R': Nrun = atoi(&argv[1][2]); break;
		case 's': single = 1; break;
		case 'V': printf("Generated by %s\n", Version);
			  exit(0); break;
		case 'w': ssize = atoi(&argv[1][2]); break;
		case 'X': efd = stdout; break;
		default : usage(efd); break;
		}
		argc--; argv++;
	}
#if defined(NOCOMP) && !defined(BITSTATE)
	if (a_cycles)
	{ fprintf(efd, "error: -DNOCOMP voids -l and -a\n");
	  exit(1);
	}
#endif
#ifdef MEMCNT
#if MEMCNT<31
	memlim  = (double) (1<<MEMCNT);
#else
	memlim  = (double) (1<<30);
	memlim *= (double) (1<<(MEMCNT-30));
#endif
#endif
#ifndef BITSTATE
	if (Nrun > 1) HASH_NR = Nrun - 1;
#endif
	if (Nrun < 1 || Nrun > 32)
	{	fprintf(efd, "error: invalid arg for -R\n");
		usage(efd);
	}
#ifndef SAFETY
	if (fairness && !a_cycles)
	{	fprintf(efd, "error: -f requires -a or -l\n");
		usage(efd);
	}
#if ACCEPT_LAB==0
	if (a_cycles)
	{	fprintf(efd, "error: no accept labels defined ");
		fprintf(efd, "in model (for option -a)\n");
		usage(efd);
	}
#endif
#endif
#if defined(PARTIAL)
#if defined(HAS_PROVIDED)
	fprintf(efd, "error: reduced search precludes ");
	fprintf(efd, "use of PROVIDED clauses\n");
	exit(1);
#endif
#if !defined(INLINE)
	fprintf(efd, "error: reduced search precludes ");
	fprintf(efd, "use of 'enabled()'\n");
	exit(1);
#endif
#if defined(HAS_PCVALUE)
	fprintf(efd, "error: reduced search precludes ");
	fprintf(efd, "use of 'pcvalue()'\n");
	exit(1);
#endif
#if defined(HAS_BADELSE)
	fprintf(efd, "error: reduced search precludes ");
	fprintf(efd, "using 'else' combined with i/o stmnts\n");
	exit(1);
#endif
#if defined(HAS_LAST)
	fprintf(efd, "error: reduced search precludes ");
	fprintf(efd, "use of _last\n");
	exit(1);
#endif
#endif
#if !defined(REACH) && !defined(BITSTATE)
	if (iterative != 0)
	fprintf(efd, "warning: -i needs -DREACH or -DBITSTATE\n");
#endif
#if defined(BITSTATE) && defined(REACH)
	fprintf(efd, "warning: -DREACH voided by -DBITSTATE\n");
#endif
#if defined(FULLSTACK) && defined(CNTRSTACK)
	fprintf(efd, "error: cannot combine");
	fprintf(efd, " -DFULLSTACK and -DCNTRSTACK\n");
	exit(1);
#endif
#ifdef VERI
#if ACCEPT_LAB>0
	if (!a_cycles && !state_tables)
	{ fprintf(efd, "warning: never-claim + accept-labels ");
	  fprintf(efd, "requires -a flag to fully verify\n");
	}
#endif
#endif
#ifndef SAFETY
#ifndef NOREDUCE
	if (!a_cycles)
	{ fprintf(efd, "hint: this search is more efficient ");
	  fprintf(efd, "if pan.c is compiled -DSAFETY\n");
	}
#endif
#ifndef NOCOMP
	if (!a_cycles)
		S_A = 0;
	else
	{	if (!fairness)
			S_A = 1; /* _a_t */
#ifndef NOFAIR
		else /* _a_t and _cnt[NFAIR] */
		  S_A = (&(now._cnt[0]) - (uchar *) &now) + NFAIR - 2;
		/* -2 because first two uchars in now are masked */
#endif
	}
#endif
#endif
	signal(SIGINT, wrapup);
	mask = ((1<<ssize)-1);	/* hash init */
	trail = (Trail *) emalloc((maxdepth+3)*sizeof(Trail));
	trail++;	/* protect trpt-1 refs at depth 0 */
	run();
	done = 1;
	wrapup(0);
}

void
usage(FILE *fd)
{
	fprintf(fd, "Valid Options are:\n");
#ifndef SAFETY
#ifdef NP
	fprintf(fd, "	-a  -> is disabled by -DNP ");
	fprintf(fd, "(-DNP compiles for -l only)\n");
#else
	fprintf(fd, "	-a  find acceptance cycles\n");
#endif
#else
	fprintf(fd, "	-a,-l,-f  -> are disabled by -DSAFETY\n");
#endif
	fprintf(fd, "	-cN stop at Nth error ");
	fprintf(fd, "(defaults to -c1)\n");
	fprintf(fd, "	-d  print state tables and stop\n");
	fprintf(fd, "	-e  create trails for all errors\n");
#ifndef NOFAIR
	fprintf(fd, "	-f  add weak fairness (to -a or -l)\n");
#endif
	fprintf(fd, "	-hN choose other hash-function 1..32\n");
	fprintf(fd, "	-i  search for shortest path to error\n");
	fprintf(fd, "	-I  like -i, but approximate and faster\n");
#ifndef SAFETY
#ifdef NP
	fprintf(fd, "	-l  find non-progress cycles\n");
#else
	fprintf(fd, "	-l  find non-progress cycles -> ");
	fprintf(fd, "disabled, requires ");
	fprintf(fd, "compilation with -DNP\n");
#endif
#endif
	fprintf(fd, "	-mN max depth N steps (default=10k)\n");
	fprintf(fd, "	-n  no listing of unreached states\n");
	fprintf(fd, "	-q  require empty chans in valid endstates\n");
#ifdef BITSTATE
	fprintf(fd, "	-RN repeat run Nx with N ");
	fprintf(fd, "[1..32] independent hash functions\n");
#endif
	fprintf(fd, "	-s  1-bit hashing (default is 2-bit)\n");
	fprintf(fd, "	-V  print SPIN version number\n");
	fprintf(fd, "	-wN hashtable of 2^N entries");
	fprintf(fd, "(defaults to -w%d)\n", ssize);
	exit(1);
}

char *
Malloc(unsigned n)
{	char *tmp;
#ifdef MEMCNT
	if (memcnt+ (double) n > memlim) goto err;
#endif
	tmp = (char *) sbrk(n);
	if ((int) tmp == -1)
	{
err:           printf("pan: out of memory\n");
#ifdef MEMCNT
		printf("	%g bytes used\n", memcnt);
		printf("	%g bytes more needed\n", (double) n);
		printf("	%g bytes limit (2^MEMCNT)\n",
			memlim);
#endif
		wrapup(0);
	}
#ifdef MEMCNT
	memcnt += n;
#endif
	return tmp;
}

#define CHUNK	4096

char *
emalloc(unsigned n) /* never released or reallocated */
{	char *tmp;
	static char *have;
	static long left = 0L;
	static long fragment = 0L;

	if (n == 0)
	        return (char *) NULL;
	if (n&(sizeof(void *)-1)) /* for proper alignment */
	        n += sizeof(void *)-(n&(sizeof(void *)-1));
	if (left < n)
	{       unsigned grow = (n < CHUNK) ? CHUNK : n;
	        have = Malloc(grow);
	        fragment += left;
	        left = grow;
	}
	tmp = have;
	have += (long) n;
	left -= (long) n;

	memset(tmp, 0, n);
	return tmp;
}
void
Uerror(char *str)
{	/* always fatal */
	uerror(str);
	wrapup(0);
}

void
uerror(char *str)
{	static char laststr[256];

	if (strcmp(str, laststr))
	printf("pan: %s (at depth %d)\n", str,
		(depthfound==-1)?depth:depthfound);
	strcpy(laststr, str);
	errors++;
	if (every_error != 0
	||  errors == upto)
		putrail();
	if (iterative != 0 && maxdepth > 0)
	{	maxdepth = (iterative == 1)?(depth-1):(depth/2);
		warned = 1;
		printf("pan: reducing search depth to %d\n",
			maxdepth);
	} else if (errors >= upto && upto != 0)
		wrapup(0);	depthfound = -1;	/* tripakis */
}

void
r_ck(uchar *which, int N, int M, short *src)
{	int i, m=0;

#ifdef VERI
	if (M == VERI) return;	/* no useful info there */
#endif
	printf("unreached in proctype %s\n", procname[M]);
	for (i = 1; i < N; i++)
	  if (which[i] == 0 && trans[M][i])
	  	xrefsrc(src[i], M, i);
	  else
		m++;
	printf("	(%d of %d states)\n", N-1-m, N-1);
}

void
xrefsrc(int lno, int M, int i)
{	Trans *T;
	for (T = trans[M][i]; T; T = T->nxt)
	if (T && T->tp)
	{	printf("\tline %d, state %d", lno, i);
		if (strcmp(T->tp, "") != 0)
			printf(", \"%s\"", T->tp);
		else if (stopstate[M][i])
			printf(", -endstate-");
		printf("\n");
	}
}

void
putrail(void)
{	int fd, i, j;
	char snap[64], fnm[256];
	if (iterative == 0 && Nr_Trails++ > 0)
		sprintf(fnm, "%s%d.trail", Source, Nr_Trails);
	else
		sprintf(fnm, "%s.trail", Source);
	if ((fd = creat(fnm, 0666)) <= 0)
	{	printf("cannot create %s\n", fnm);
		return;
	}
#ifdef VERI
	sprintf(snap, "-2:%d:-2\n", VERI);
	write(fd, snap, strlen(snap));
#endif
	for (i = 1; i <= depth; i++)
	{	if (i == depthfound+1)
			write(fd, "-1:-1:-1\n", 9);
		if (trail[i].o_pm&128) continue;
		sprintf(snap, "%d:%d:%d\n", 
			i, trail[i].pr, trail[i].o_t->t_id);
		j = strlen(snap);
		if (write(fd, snap, j) != j)
		{	printf("pan: error writing %s\n", fnm);
			close(fd);
			wrapup(0);
		}
	}
	printf("pan: wrote %s\n", fnm);
	close(fd);
}

void
sv_save(char *won)	/* push state vector onto save stack */
{
	if (!svtack->nxt)
	{  svtack->nxt = (Svtack *) emalloc(sizeof(Svtack));
	   svtack->nxt->body = emalloc(vsize*sizeof(char));
	   svtack->nxt->lst = svtack;
	   svtack->nxt->m_delta = vsize;
	   svmax++;
	} else if (vsize > svtack->nxt->m_delta)
	{  svtack->nxt->body = emalloc(vsize*sizeof(char));
	   svtack->nxt->lst = svtack;
	   svtack->nxt->m_delta = vsize;
	   svmax++;
	}
	svtack = svtack->nxt;
#if SYNC
	svtack->o_boq = boq;
#endif
	svtack->o_delta = vsize; /* don't compress */
	memcpy((char *)(svtack->body), won, vsize);
#ifdef DEBUG
	printf("%d:	sv_save\n", depth);
#endif
}

void
sv_restor(int nonatom)	/* pop state vector from save stack */
{
#if defined(FULLSTACK) && defined(NOCOMP) && !defined(BITSTATE)
	if (nonatom)
	{	memcpy((char *)&now,
		  &(((struct H_el *)(trpt-1)->ostate)->state),
		  vsize);
	} else
#endif
	{	memcpy((char *)&now,
			svtack->body, svtack->o_delta);
#if SYNC
		boq = svtack->o_boq;
#endif
		if (vsize != svtack->o_delta)
			Uerror("sv_restor");
		if (!svtack->lst)
			Uerror("error: v_restor");
		svtack  = svtack->lst;
	}
#ifdef DEBUG
	printf("	sv_restor\n");
#endif
}

void
p_restor(int h)
{	int i; char *z = (char *) &now;

	proc_offset[h] = stack->o_offset;
	proc_skip[h]   = stack->o_skip;
#ifndef XUSAFE
	p_name[h] = stack->o_name;
#endif
#ifndef NOCOMP
	for (i = vsize + stack->o_skip; i > vsize; i--)
		Mask[i-1] = 1; /* align */
#endif
	vsize += stack->o_skip;
	memcpy(z+vsize, stack->body, stack->o_delta);
	vsize += stack->o_delta;
#ifndef NOVSZ
	now._vsz = vsize;
#endif
#ifndef NOCOMP
	for (i = 1; i <= Air[((P0 *)pptr(h))->_t]; i++)
		Mask[vsize - i] = 1; /* pad */
	Mask[proc_offset[h]] = 1;	/* _pid */
#endif
	if (BASE > 0 && h > 0)
		((P0 *)pptr(h))->_pid = h-BASE;
	else
		((P0 *)pptr(h))->_pid = h;
	i = stack->o_delqs;
	now._nr_pr += 1;
	if (!stack->lst)	/* debugging */
		Uerror("error: p_restor");
	stack = stack->lst;
	this = pptr(h);
	while (i-- > 0)
		q_restor();
}

void
q_restor(void)
{	int k; char *z = (char *) &now;

	q_offset[now._nr_qs] = stack->o_offset;
	q_skip[now._nr_qs]   = stack->o_skip;
#ifndef XUSAFE
	q_name[now._nr_qs]   = stack->o_name;
#endif
	vsize += stack->o_skip;
	memcpy(z+vsize, stack->body, stack->o_delta);
	vsize += stack->o_delta;
#ifndef NOVSZ
	now._vsz = vsize;
#endif
	now._nr_qs += 1;
#ifndef NOCOMP
	k = vsize + stack->o_skip;
#if SYNC
	if (q_zero(now._nr_qs)) k += stack->o_delta;
#endif
	for ( ; k > vsize; k--)
		Mask[k-1] = 1; /* align */
#endif
	if (!stack->lst)	/* debugging */
		Uerror("error: q_restor");
	stack = stack->lst;
}

int
delproc(int sav, int h)
{	int d, i=0, o_vsize = vsize;

	if (h+1 != (int) now._nr_pr) return 0;

	while (now._nr_qs
	&&     q_offset[now._nr_qs-1] > proc_offset[h])
	{	delq(sav);
		i++;
	}
	d = vsize - proc_offset[h];
	if (sav)
	{	if (!stack->nxt)
		{	stack->nxt = (Stack *)
				emalloc(sizeof(Stack));
			stack->nxt->body = 
				emalloc(Maxbody*sizeof(char));
			stack->nxt->lst = stack;
			smax++;
		}
		stack = stack->nxt;
		stack->o_offset = proc_offset[h];
		stack->o_skip   = proc_skip[h];
#ifndef XUSAFE
		stack->o_name   = p_name[h];
#endif
		stack->o_delta  = d;
		stack->o_delqs  = i;
		memcpy(stack->body, (char *)pptr(h), d);
	}
	vsize = proc_offset[h];
	now._nr_pr = now._nr_pr - 1;
	memset((char *)pptr(h), 0, d);
	vsize -= proc_skip[h];
#ifndef NOVSZ
	now._vsz = vsize;
#endif
#ifndef NOCOMP
	for (i = vsize; i < o_vsize; i++)
		Mask[i] = 0; /* reset */
#endif
	return 1;
}

void
delq(int sav)
{	int h = now._nr_qs - 1;
	int d = vsize - q_offset[now._nr_qs - 1];
#ifndef NOCOMP
	int k, o_vsize = vsize;
#endif
	if (sav)
	{	if (!stack->nxt)
		{	stack->nxt = (Stack *)
				emalloc(sizeof(Stack));
			stack->nxt->body = 
				emalloc(Maxbody*sizeof(char));
			stack->nxt->lst = stack;
			smax++;
		}
		stack = stack->nxt;
		stack->o_offset = q_offset[h];
		stack->o_skip   = q_skip[h];
#ifndef XUSAFE
		stack->o_name   = q_name[h];
#endif
		stack->o_delta  = d;
		memcpy(stack->body, (char *)qptr(h), d);
	}
	vsize = q_offset[h];
	now._nr_qs = now._nr_qs - 1;
	memset((char *)qptr(h), 0, d);
	vsize -= q_skip[h];
#ifndef NOVSZ
	now._vsz = vsize;
#endif
#ifndef NOCOMP
	for (k = vsize; k < o_vsize; k++)
		Mask[k] = 0; /* reset */
#endif
}

int
qs_empty(void)
{	int i; Q0 *qtr;
	for (i = 0; i < (int) now._nr_qs; i++)
	{	if (q_sz(i) > 0)
			return 0;
	}
	return 1;
}

int
endstate(void)
{	int i; P0 *ptr;
	for (i = BASE; i < (int) now._nr_pr; i++)
	{	ptr = (P0 *) pptr(i);
		if (!stopstate[ptr->_t][ptr->_p])
			return 0;
	}
	if (strict) return qs_empty();
	return 1;
}

#ifndef SAFETY
void
checkcycles(void)
{
#ifdef FULLSTACK
	struct H_el *sv = trpt->ostate; /* save */
#endif
#ifdef DEBUG
	{ int i; uchar *v = (uchar *) &now;
	  printf("	set Seed state ");
	  if (fairness) printf("(cnt = %d) ", now._nr_pr);
	/* for (i = 0; i < n; i++) printf("%d,", v[i]);	*/
	  printf("\n");
	}
	printf("%d: cycle check starts\n", depth);
#endif
	now._a_t |= (1|16|32);
	/* 1 = 2nd DFS; (16|32) to help hasher */
#ifndef NOFAIR
	if (fairness) now._cnt[1] = 0;
#endif
	memcpy((char *)&A_Root, (char *)&now, vsize);
	A_depth = depthfound = depth;
	if (fairness) now._a_t &= ~2;	/* pre-apply Rule 3 */
	/* avoids matching seed on claim stutter on this state */
	new_state();	/* start 2nd DFS */
	if (fairness) now._a_t |= 2;	/* undo Rule 3 */
	A_depth = 0; depthfound = -1;
	now._a_t &= ~(1|16|32);
#ifdef DEBUG
	printf("%d: cycle check returns\n", depth);
#endif
#ifdef FULLSTACK
	trpt->ostate = sv;	/* restore */
#endif
}
#endif

#if defined(FULLSTACK) && defined(BITSTATE)
struct H_el *Free_list = (struct H_el *) 0;
void
onstack_init(void)
{	S_tab = (struct H_el **)
		emalloc((1<<(ssize-3))*sizeof(struct H_el *));
}
struct H_el *
grab_state(int n)
{	register struct H_el *v, *last = 0;

	if (H_tab == S_tab)
	for (v = Free_list; v && v->tagged >= n; v=v->nxt)
	{	if (v->tagged == n)
		{	if (last)
				last->nxt = v->nxt;
			else
				Free_list = v->nxt;
			v->tagged = 0;
			v->nxt = 0;
#ifdef COLLAPSE
			v->ln = 0;
#endif
			return v;
		}
		Fh++; last=v;
	}
	ngrabs++;
	return (struct H_el *)
	      emalloc(sizeof(struct H_el)+n-sizeof(unsigned));
}

#else
#define grab_state(n) (struct H_el *) \
		emalloc(sizeof(struct H_el)+n-sizeof(unsigned));
#endif
#if !defined(BITSTATE) && !defined(NOCOMP)
#ifdef COLLAPSE
unsigned ncomps = 1;
unsigned
ordinal(char *v, int n) /* store components */
{	struct H_el *tmp, *ntmp; int m;
	struct H_el *olst = (struct H_el *) 0;

	s_hash((uchar *)v, n);
	tmp = H_tab[j1];
	if (!tmp)
	{	tmp = grab_state(n);
		H_tab[j1] = tmp;
	} else
	for ( ;; olst = tmp, tmp = tmp->nxt)
	{	m = memcmp(((char *)&(tmp->state)), v, n);
		if (n == tmp->ln)
		{
			if (m == 0)
				goto done;
			if (m < 0)
			{
Insert:			ntmp = grab_state(n);
				ntmp->nxt = tmp;
				if (!olst)
					H_tab[j1] = ntmp;
				else
					olst->nxt = ntmp;
				tmp = ntmp;
				break;
			} else if (!tmp->nxt)
			{
Append:			tmp->nxt = grab_state(n);
				tmp = tmp->nxt;
				break;
			}
			continue;
		}
		if (n < tmp->ln)
			goto Insert;
		else if (!tmp->nxt)
			goto Append;
	}
#ifdef FULLSTACK
	tmp->tagged = ncomps++;
#else
	tmp->st_id  = ncomps++;
#endif
	memcpy(((char *)&(tmp->state)), v, n);
	tmp->ln = n;
done:
#ifdef FULLSTACK
	return tmp->tagged;
#else
	return tmp->st_id;
#endif
}

int
compress(char *vin, int nin)
{	register char	*w = (char *) &now;
	register char	*v = (char *) &comp_now;
	register int	i;
	unsigned long	n;
	unsigned col_q(int);

#ifndef SAFETY
	if (a_cycles)
		*v++ = *w++;	/* _a_t */
#ifndef NOFAIR
	if (fairness)
	{	w = (char *) &(now._cnt[0]);
		for (i = 0; i < NFAIR; i++)
			*v++ = *w++;
	}
	w = (char *) &(now._cnt[NFAIR]);
#endif
#endif
	if (((unsigned long)w)%WS)
		w += WS-((unsigned long)w)%WS;	/* realign */
	if (qptr(0) < pptr(0)) /* globals - no queues */
		n = qptr(0) - (unsigned char *) w;
	else
		n = pptr(0) - (unsigned char *) w;
	if (n)
	{	n = ordinal(w, n);
		*v++ = n&255;
#ifdef COLLAPSE4
		if ((n>>8)&255) Uerror("too big for COLLAPSE4");
#else
		*v++ = (n>>8)&255;
#endif
#ifdef COLLAPSE3
		if ((n>>16)&255) Uerror("too big for COLLAPSE3");
#else
		*v++ = (n>>16)&255;
#endif
#ifdef COLLAPSE2
		if ((n>>24)&255) Uerror("too big for COLLAPSE2");
#else
		*v++ = (n>>24)&255;
#endif
	}

	for (i = 0; i < (int) now._nr_pr; i++)
	{	n = col_p(i);
		*v++ = n&255;
#ifdef COLLAPSE4
		if ((n>>8)&255)
			Uerror("too big for COLLAPSE4");
#else
		*v++ = (n>>8)&255;
#endif
#ifdef COLLAPSE3
		if ((n>>16)&255)
			Uerror("too big for COLLAPSE3");
#else
		*v++ = (n>>16)&255;
#endif
#ifdef COLLAPSE2
		if ((n>>24)&255)
			Uerror("too big for COLLAPSE2");
#else
		*v++ = (n>>24)&255;
#endif
	}
	for (i = 0; i < (int) now._nr_qs; i++)
	{
#if 0
	/* these are no longer joined with globals */
		if (qptr(i) < pptr(0))
			continue;
#endif
		n = col_q(i);
		*v++ = n&255;
#ifdef COLLAPSE4
		if ((n>>8)&255)
			Uerror("too big for COLLAPSE4");
#else
		*v++ = (n>>8)&255;
#endif
#ifdef COLLAPSE3
		if ((n>>16)&255)
			Uerror("too big for COLLAPSE3");
#else
		*v++ = (n>>16)&255;
#endif
#ifdef COLLAPSE2
		if ((n>>24)&255)
			Uerror("too big for COLLAPSE2");
#else
		*v++ = (n>>24)&255;
#endif
	}
	for (i = 0; i < WS-1; i++)
		*v++ = 0;
	v -= i;
#if 0
	printf("collapse %d -> %d\n",
		vsize, v - (char *)&comp_now);
#endif
	return v - (char *)&comp_now;
}
#else
int
compress(char *vin, int n)
{	register char *vv = vin;
	register char *v = (char *) &comp_now;
	register int i;
	for (i = 0; i < n; i++, vv++)
		if (!Mask[i]) *v++ = *vv;
	for (i = 0; i < WS-1; i++)
		*v++ = 0;
	v -= i;
#if 0
	printf("compress %d -> %d\n",
		n, v - (char *)&comp_now);
#endif
	return v - (char *)&comp_now;
}
#endif
#endif
#if defined(FULLSTACK) && defined(BITSTATE)
void
onstack_zap(void)
{	register struct H_el *v, *w, *last = 0;
	struct H_el **tmp = H_tab;
	int m;

#ifndef NOCOMP
	char *nv = (char *) &comp_now;
	int n = compress((char *)&now, vsize);
#else
	char *nv = (char *) &now;
	int n = vsize;
#endif
	H_tab = S_tab;
	s_hash((uchar *)nv, n);
	H_tab = tmp;
	for (v = S_tab[j1]; v; Zh++, last=v, v=v->nxt)
	{	m = memcmp(&(v->state), nv, n);
		if (m == 0)
			goto Found;
		if (m < 0)
			break;
	}
NotFound:
	Uerror("stack out of wack - zap");
	return;
Found:
	ZAPS++;
	if (last)
		last->nxt = v->nxt;
	else
		S_tab[j1] = v->nxt;
	v->tagged = n;
#if defined(PARTIAL) && !defined(SAFETY)
	v->proviso = 0;
#endif
	v->nxt = last = (struct H_el *) 0;
	for (w = Free_list; w; Fa++, last=w, w = w->nxt)
	{	if (w->tagged <= n)
		{	if (last)
			{	v->nxt = w->nxt;
				last->nxt = v;
			} else
			{	v->nxt = Free_list;
				Free_list = v;
			}
			return;
		}
		if (!w->nxt)
		{	w->nxt = v;
			return;
	}	}
	Free_list = v;
}
void
onstack_put(void)
{	struct H_el **tmp = H_tab;
	H_tab = S_tab;
	if (hstore((char *)&now, vsize, 3) != 0)
		Uerror("cannot happen - unstack_put");
	H_tab = tmp;
	trpt->ostate = Lstate;
	PUT++;
}
int
onstack_now(void)
{	register struct H_el *tmp;
	struct H_el **tmp2 = H_tab;
	int m = 1;

#ifndef NOCOMP
	char *v = (char *) &comp_now;
	int n = compress((char *)&now, vsize);
#else
	char *v = (char *) &now;
	int n = vsize;
#endif
	H_tab = S_tab;
	s_hash((uchar *)v, n);
	H_tab = tmp2;
	for (tmp = S_tab[j1]; tmp; Zn++, tmp = tmp->nxt)
	{	m = memcmp(((char *)&(tmp->state)),v,n);
		if (m <= 0)
		{	Lstate = tmp;
			break;
	}	}
	PROBE++;
	return (m == 0);
}
#endif
#ifndef BITSTATE
void
hinit(void)
{	H_tab = (struct H_el **)
		emalloc((1<<ssize)*sizeof(struct H_el *));
}
#endif

#if !defined(BITSTATE) || defined(FULLSTACK)
#ifdef DEBUG
void
dumpstate(int wasnew, char *v, int n, int tag)
{	int i;
#ifndef SAFETY
	if (S_A)
	{	printf("	state tags %d (%d::%d): ",
			V_A, wasnew, v[0]);
#ifdef FULLSTACK
		printf(" %d ", tag);
#endif
		printf("\n");
	}
#endif
#ifdef SDUMP
#ifndef NOCOMP
	printf("	 State: ");
	for (i = 0; i < vsize; i++) printf("%d%s,",
		((char *)&now)[i], Mask[i]?"*":"");
#endif
	printf("\n	Vector: ");
	for (i = 0; i < n; i++) printf("%d,", v[i]);
	printf("\n");
#endif
}
#endif
int
hstore(char *vin, int nin, short xx)
{	register struct H_el *tmp; int m=0;
	struct	H_el *ntmp, *olst = (struct H_el *) 0;
#ifndef NOCOMP
	char	*v = (char *) &comp_now;
	int	 n = compress(vin, nin);
#ifndef SAFETY
	if (S_A)
	{	v[0] = 0;	/* _a_t  */
#ifndef NOFAIR
		if (S_A > NFAIR)
		for (m = 0; m < NFAIR; m++)
			v[m+1] = 0;	/* _cnt[] */
#endif
		m = 0;
	}
#endif
#else
	char	*v = vin;
	int	n = nin;
#endif
	s_hash((uchar *)v, n);
	tmp = H_tab[j1];
	if (!tmp)
	{  tmp = grab_state(n);
	   H_tab[j1] = tmp;
	} else
	{  for (;; hcmp++, olst = tmp, tmp = tmp->nxt)
	   {   /* skip the _a_t and the _cnt bytes */
#ifdef COLLAPSE
		if (tmp->ln != 0)
		{	if (!tmp->nxt) goto Append;
			continue;
		}
#endif
#ifdef SAFETY
	       m = memcmp(((char *)&(tmp->state)), v, n);
	       if (m == 0)
	       {
#define wasnew	0
#else
		m = memcmp(((char *)&(tmp->state)) + S_A, 
			v + S_A, n - S_A);
		if (m == 0)
		{ int wasnew = 0;
#endif
#ifndef SAFETY
#ifndef NOCOMP
		if (S_A)
		{ if ((((char *)&(tmp->state))[0] & V_A) != V_A)
		  {	wasnew = 1; nShadow++;
			((char *)&(tmp->state))[0] |= V_A;
		  }
#ifndef NOFAIR
		  if (S_A > NFAIR)
		  {	/* 0 <= now._cnt[now._a_t&1] < MAXPROC */
			unsigned ci, bp; /* index, bit pos */
			ci = (now._cnt[now._a_t&1] / 8);
			bp = (now._cnt[now._a_t&1] - 8*ci);
			if (now._a_t&1)	/* use tail-bits in _cnt */
			{	ci = (NFAIR - 1) - ci;
				bp = 7 - bp; /* bp = 0..7 */
			}
			ci++;	/* skip over _a_t */
			bp = 1 << bp;	/* the bit mask */
			if ((((char *)&(tmp->state))[ci] & bp)==0)
			{	if (!wasnew)
				{	wasnew = 1;
					nShadow++;
				}
				((char *)&(tmp->state))[ci] |= bp;
			}
		   }
		   /* else: wasnew == 0, i.e., old state */
#endif
		}
#endif
#endif
#ifdef FULLSTACK
			if (wasnew)
			{	Lstate = tmp;
				tmp->tagged |= V_A;
				if ((tmp->tagged&A_V)
				&& (now._a_t&1)
				&& depth > A_depth)
				{
#ifdef CHECK
	printf("1st dfs-stack intersected on state %d+\n",
		(int) tmp->st_id);
#endif
					return 3;
				}
#ifdef CHECK
	printf("	New state %d+\n", (int) tmp->st_id);
#endif
#ifdef DEBUG
	dumpstate(1, (char *)&(tmp->state),n,tmp->tagged);
#endif
				return 0;
			} else if ((S_A)?(tmp->tagged&V_A):tmp->tagged)
			{	Lstate = tmp;
#ifdef CHECK
	printf("	Old state %d\n", (int) tmp->st_id);
#endif
#ifdef DEBUG
	dumpstate(0, (char *)&(tmp->state),n,tmp->tagged);
#endif
					return 2; /* match on stack */
			}
#else
			if (wasnew)
			{
#ifdef CHECK
	printf("	New state %d+\n", (int) tmp->st_id);
#endif
#ifdef DEBUG
	dumpstate(1, (char *)&(tmp->state), n, 0);
#endif
				return 0;
			}
#endif
#ifdef CHECK
	printf("	Old state %d\n", (int) tmp->st_id);
#endif
#ifdef DEBUG
	dumpstate(0, (char *)&(tmp->state), n, 0);
#endif
#ifdef REACH
			if (tmp->D > depth)
			{	tmp->D = depth;
#ifdef CHECK
	printf("		ReVisiting (from smaller depth)\n");
#endif
				nstates--;
				return 0;
			}
#endif
			return 1; /* match outside stack */
	       } else if (m < 0)
	       {	/* insert state before tmp */
			ntmp = grab_state(n);
			ntmp->nxt = tmp;
			if (!olst)
				H_tab[j1] = ntmp;
			else
				olst->nxt = ntmp;
			tmp = ntmp;
			break;
	       } else if (!tmp->nxt)
	       {	/* append after tmp */
Append:		tmp->nxt = grab_state(n);
			tmp = tmp->nxt;
			break;
	   }   }
	}
#ifdef CHECK
	tmp->st_id = (unsigned) nstates;
#ifdef BITSTATE
	printf("	Push state %d\n", ((int) nstates) - 1);
#else
	printf("	New state %d\n", (int) nstates);
#endif
#endif
#ifdef REACH
	tmp->D = depth;
#endif
#ifndef SAFETY
#ifndef NOCOMP
	if (S_A)
	{	v[0] = V_A;
#ifndef NOFAIR
		if (S_A > NFAIR)
		{	unsigned ci, bp; /* as above */
			ci = (now._cnt[now._a_t&1] / 8);
			bp = (now._cnt[now._a_t&1] - 8*ci);
			if (now._a_t&1)
			{	ci = (NFAIR - 1) - ci;
				bp = 7 - bp; /* bp = 0..7 */
			}
			v[1+ci] = 1 << bp;
		}
#endif
	}
#endif
#endif
	memcpy(((char *)&(tmp->state)), v, n);
#ifdef FULLSTACK
	tmp->tagged = (S_A)?V_A:(depth+1);
	Lstate = tmp;
#ifdef DEBUG
	dumpstate(-1, v, n, tmp->tagged);
#endif
#else
#ifdef DEBUG
	dumpstate(-1, v, n, 0);
#endif
#endif
	return 0;
}
#endif
#include "pan.t"
void
do_reach(void)
{
	r_ck(reached0, nstates0, 0, src_ln0);
	r_ck(reached1, nstates1, 1, src_ln1);
	r_ck(reached2, nstates2, 2, src_ln2);
	r_ck(reached3, nstates3, 3, src_ln3);
	r_ck(reached4, nstates4, 4, src_ln4);
	r_ck(reached5, nstates5, 5, src_ln5);
	r_ck(reached6, nstates6, 6, src_ln6);
}

void
iniglobals(void)
{
		now.user_to_appl[0] = addqueue(1, 1);
		now.user_to_appl[1] = addqueue(2, 1);
		now.appl_to_llc[0] = addqueue(3, 1);
		now.appl_to_llc[1] = addqueue(4, 1);
		now.llc_to_appl[0] = addqueue(5, 0);
		now.llc_to_appl[1] = addqueue(6, 0);
		now.regist_to_llc = addqueue(7, 1);
		now.llc_to_regist = addqueue(8, 0);
		now.leaveall_to_llc = addqueue(9, 1);
		now.llc_to_leaveall = addqueue(10, 0);
#ifdef VAR_RANGES
#endif
}

int
addqueue(int n, int is_rv)
{	int j=0, i = now._nr_qs, k;

	if (i >= MAXQ)
		Uerror("too many queues");
	switch (n) {
	case 10: j = sizeof(Q10); q_flds[10] = 1; break;
	case 9: j = sizeof(Q9); q_flds[9] = 1; break;
	case 8: j = sizeof(Q8); q_flds[8] = 1; break;
	case 7: j = sizeof(Q7); q_flds[7] = 1; break;
	case 6: j = sizeof(Q6); q_flds[6] = 1; break;
	case 5: j = sizeof(Q5); q_flds[5] = 1; break;
	case 4: j = sizeof(Q4); q_flds[4] = 1; break;
	case 3: j = sizeof(Q3); q_flds[3] = 1; break;
	case 2: j = sizeof(Q2); q_flds[2] = 1; break;
	case 1: j = sizeof(Q1); q_flds[1] = 1; break;
	default: Uerror("bad queue - addqueue");
	}
	if (vsize%WS)
		q_skip[i] = WS-(vsize%WS);
	else
		q_skip[i] = 0;
#ifndef NOCOMP
	k = vsize; if (is_rv) k += j;
	for (k += q_skip[i]; k > vsize; k--)
		Mask[k-1] = 1; /* align */
#endif
	vsize += q_skip[i];
	q_offset[i] = vsize;
	now._nr_qs += 1;
	vsize += j;
#ifndef NOVSZ
	now._vsz = vsize;
#endif
	hmax = max(hmax, vsize);
	if (vsize >= VECTORSZ)
		Uerror("VECTORSZ is too small, edit pan.h");
	memset((char *)qptr(i), 0, j);
	((Q0 *)qptr(i))->_t = n;
	return i+1;
}

void
qsend(int into, int sorted, int fld0)
{	int j, k; uchar *z;

	if (!into--)
	uerror("ref to uninitialized chan name (sending)");
	if (into >= (int) now._nr_qs || into < 0)
		Uerror("qsend bad queue#");
	z = qptr(into);
	j = ((Q0 *)qptr(into))->Qlen;
	switch (((Q0 *)qptr(into))->_t) {
	case 10:
		(trpt+1)->oval = j;
		((Q10 *)z)->Qlen = ((Q10 *)z)->Qlen + 1;
		((Q10 *)z)->contents[j].fld0 = fld0;
		break;
	case 9: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q9 *)z)->Qlen = ((Q9 *)z)->Qlen + 1;
		((Q9 *)z)->contents[j].fld0 = fld0;
		break;
	case 8:
		(trpt+1)->oval = j;
		((Q8 *)z)->Qlen = ((Q8 *)z)->Qlen + 1;
		((Q8 *)z)->contents[j].fld0 = fld0;
		break;
	case 7: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q7 *)z)->Qlen = ((Q7 *)z)->Qlen + 1;
		((Q7 *)z)->contents[j].fld0 = fld0;
		break;
	case 6:
		(trpt+1)->oval = j;
		((Q6 *)z)->Qlen = ((Q6 *)z)->Qlen + 1;
		((Q6 *)z)->contents[j].fld0 = fld0;
		break;
	case 5:
		(trpt+1)->oval = j;
		((Q5 *)z)->Qlen = ((Q5 *)z)->Qlen + 1;
		((Q5 *)z)->contents[j].fld0 = fld0;
		break;
	case 4: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q4 *)z)->Qlen = ((Q4 *)z)->Qlen + 1;
		((Q4 *)z)->contents[j].fld0 = fld0;
		break;
	case 3: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q3 *)z)->Qlen = ((Q3 *)z)->Qlen + 1;
		((Q3 *)z)->contents[j].fld0 = fld0;
		break;
	case 2: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q2 *)z)->Qlen = ((Q2 *)z)->Qlen + 1;
		((Q2 *)z)->contents[j].fld0 = fld0;
		break;
	case 1: /* =rv= */
		(trpt+2)->o_m = 0;
		(trpt+1)->oval = j;
		((Q1 *)z)->Qlen = ((Q1 *)z)->Qlen + 1;
		((Q1 *)z)->contents[j].fld0 = fld0;
		break;
	case 0: printf("queue %d was deleted\n", into+1);
	default: Uerror("bad queue - qsend");
	}
}

#if SYNC
int
q_zero(int from)
{	if (!from--)
	uerror("ref to uninitialized chan name (q_zero)");
	switch(((Q0 *)qptr(from))->_t) {
	case 10: return 0;
	case 9: return 1;
	case 8: return 0;
	case 7: return 1;
	case 6: return 0;
	case 5: return 0;
	case 4: return 1;
	case 3: return 1;
	case 2: return 1;
	case 1: return 1;
	case 0: printf("queue %d was deleted\n", from+1);
	}
	Uerror("bad queue q-zero");
}
int
not_RV(int from)
{	if (q_zero(from))
	{	printf("==>> a test of the contents of a rv ");
		printf("channel always returns FALSE\n");
		uerror("error to poll rendezvous channel");
	}
	return 1;
}
#endif
#ifndef XUSAFE
void
setq_claim(int x, int m, char *s, int y, char *p)
{	if (x == 0)
	uerror("x[rs] claim on uninitialized channel");
	if (x < 0 || x > MAXQ)
		Uerror("cannot happen setq_claim");
	q_claim[x] |= m;
	p_name[y] = p;
	q_name[x] = s;
	if (m&2) q_S_check(x, y);
	if (m&1) q_R_check(x, y);
}
short q_sender[MAXQ+1];
int
q_S_check(int x, int who)
{	if (!q_sender[x])
	{	q_sender[x] = who+1;
#if SYNC
		if (q_zero(x))
		{	printf("chan %s (%d), ",
				q_name[x], x-1);
			printf("sndr proc %s (%d)\n",
				p_name[who], who);
			uerror("xs chans cannot be used for rv");
		}
#endif
	} else
	if (q_sender[x] != who+1)
	{	printf("pan: xs assertion violated: ");
		printf("access to chan <%s> (%d)\npan: by ",
			q_name[x], x-1);
		printf("%s (proc %d) and by %s (proc %d)\n",
			p_name[q_sender[x]-1], q_sender[x]-1,
			p_name[who], who);
		uerror("error, partial order reduction invalid");
	}
	return 1;
}
short q_recver[MAXQ+1];
int
q_R_check(int x, int who)
{	if (!q_recver[x])
	{	q_recver[x] = who+1;
#if SYNC
		if (q_zero(x))
		{	printf("chan %s (%d), ",
				q_name[x], x-1);
			printf("recv proc %s (%d)\n",
				p_name[who], who);
			uerror("xr chans cannot be used for rv");
		}
#endif
	} else
	if (q_recver[x] != who+1)
	{	printf("pan: xr assertion violated: ");
		printf("access to chan %s (%d)\n",
			q_name[x], x-1);
		printf("pan: by %s (proc %d) ",
			p_name[q_recver[x]-1], q_recver[x]-1);
		printf("and by %s (proc %d)\n",
			p_name[who], who);
		uerror("error, partial order reduction invalid");
	}
	return 1;
}
#endif
int
q_len(int x)
{	if (!x--)
	uerror("ref to uninitialized chan name (len)");
	return ((Q0 *)qptr(x))->Qlen;
}

int
q_full(int from)
{	if (!from--)
	uerror("ref to uninitialized chan name (qfull)");
	switch(((Q0 *)qptr(from))->_t) {
	case 10: return (q_sz(from) == 1);
	case 9: return (q_sz(from) == 1);
	case 8: return (q_sz(from) == 1);
	case 7: return (q_sz(from) == 1);
	case 6: return (q_sz(from) == 1);
	case 5: return (q_sz(from) == 1);
	case 4: return (q_sz(from) == 1);
	case 3: return (q_sz(from) == 1);
	case 2: return (q_sz(from) == 1);
	case 1: return (q_sz(from) == 1);
	case 0: printf("queue %d was deleted\n", from+1);
	}
	Uerror("bad queue - q_full");
	return 0;
}

int
qrecv(int from, int slot, int fld, int done)
{	uchar *z;
	int j, k, r=0;

	if (!from--)
	uerror("ref to uninitialized chan name (receiving)");
	if (from >= (int) now._nr_qs || from < 0)
		Uerror("qrecv bad queue#");
	z = qptr(from);
	switch (((Q0 *)qptr(from))->_t) {
	case 10:
		if (fld == 0) r = ((Q10 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q10 *)z)->Qlen;
			((Q10 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q10 *)z)->contents[k].fld0 = 
					((Q10 *)z)->contents[k+1].fld0;
			}
			((Q10 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 9: /* =rv= */
		if (fld == 0) r = ((Q9 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q9 *)z)->Qlen;
			((Q9 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q9 *)z)->contents[k].fld0 = 
					((Q9 *)z)->contents[k+1].fld0;
			}
			((Q9 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 8:
		if (fld == 0) r = ((Q8 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q8 *)z)->Qlen;
			((Q8 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q8 *)z)->contents[k].fld0 = 
					((Q8 *)z)->contents[k+1].fld0;
			}
			((Q8 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 7: /* =rv= */
		if (fld == 0) r = ((Q7 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q7 *)z)->Qlen;
			((Q7 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q7 *)z)->contents[k].fld0 = 
					((Q7 *)z)->contents[k+1].fld0;
			}
			((Q7 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 6:
		if (fld == 0) r = ((Q6 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q6 *)z)->Qlen;
			((Q6 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q6 *)z)->contents[k].fld0 = 
					((Q6 *)z)->contents[k+1].fld0;
			}
			((Q6 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 5:
		if (fld == 0) r = ((Q5 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q5 *)z)->Qlen;
			((Q5 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q5 *)z)->contents[k].fld0 = 
					((Q5 *)z)->contents[k+1].fld0;
			}
			((Q5 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 4: /* =rv= */
		if (fld == 0) r = ((Q4 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q4 *)z)->Qlen;
			((Q4 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q4 *)z)->contents[k].fld0 = 
					((Q4 *)z)->contents[k+1].fld0;
			}
			((Q4 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 3: /* =rv= */
		if (fld == 0) r = ((Q3 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q3 *)z)->Qlen;
			((Q3 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q3 *)z)->contents[k].fld0 = 
					((Q3 *)z)->contents[k+1].fld0;
			}
			((Q3 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 2: /* =rv= */
		if (fld == 0) r = ((Q2 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q2 *)z)->Qlen;
			((Q2 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q2 *)z)->contents[k].fld0 = 
					((Q2 *)z)->contents[k+1].fld0;
			}
			((Q2 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 1: /* =rv= */
		if (fld == 0) r = ((Q1 *)z)->contents[slot].fld0;
		if (done)
		{	j = ((Q1 *)z)->Qlen;
			((Q1 *)z)->Qlen = --j;
			for (k=slot; k<j; k++)
			{
				((Q1 *)z)->contents[k].fld0 = 
					((Q1 *)z)->contents[k+1].fld0;
			}
			((Q1 *)z)->contents[j].fld0 = 0;
			if (fld+1 != 1)
				uerror("missing pars in receive");
		}
		break;
	case 0: printf("queue %d was deleted\n", from+1);
	default: Uerror("bad queue - qrecv");
	}
	return r;
}

#ifndef BITSTATE
#ifdef COLLAPSE
unsigned
col_q(int i)
{	int j;
	Q0 *ptr = (Q0 *) qptr(i);
	switch (ptr->_t) {
	case 10: j = sizeof(Q10); break;
	case 9: j = sizeof(Q9); break;
	case 8: j = sizeof(Q8); break;
	case 7: j = sizeof(Q7); break;
	case 6: j = sizeof(Q6); break;
	case 5: j = sizeof(Q5); break;
	case 4: j = sizeof(Q4); break;
	case 3: j = sizeof(Q3); break;
	case 2: j = sizeof(Q2); break;
	case 1: j = sizeof(Q1); break;
	default: Uerror("bad type - collapse");
	}
	return ordinal((char *)ptr, j);
}
#endif
#endif
int 
unsend(int into)
{	int m=0, j, k; uchar *z;

	if (!into--)
		uerror("ref to uninitialized chan (unsend)");
	z = qptr(into);
	j = ((Q0 *)z)->Qlen;
	((Q0 *)z)->Qlen = --j;
	switch (((Q0 *)qptr(into))->_t) {
	case 10:
		((Q10 *)z)->contents[j].fld0 = 0;
		m = trpt->o_m;
		break;
	case 9:
		((Q9 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	case 8:
		((Q8 *)z)->contents[j].fld0 = 0;
		m = trpt->o_m;
		break;
	case 7:
		((Q7 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	case 6:
		((Q6 *)z)->contents[j].fld0 = 0;
		m = trpt->o_m;
		break;
	case 5:
		((Q5 *)z)->contents[j].fld0 = 0;
		m = trpt->o_m;
		break;
	case 4:
		((Q4 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	case 3:
		((Q3 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	case 2:
		((Q2 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	case 1:
		((Q1 *)z)->contents[j].fld0 = 0;
		m = (trpt+1)->o_m;
		if (m) (trpt-1)->o_pm |= 1;
		UnBlock;
		break;
	default: Uerror("bad queue - unsend");
	}
	return m;
}

void
unrecv(int from, int slot, int fld, int fldvar, int strt)
{	int j; uchar *z;

	if (!from--)
		uerror("ref to uninitialized chan (unrecv)");
	z = qptr(from);
	j = ((Q0 *)z)->Qlen;
	if (strt) ((Q0 *)z)->Qlen = j+1;
	switch (((Q0 *)qptr(from))->_t) {
	case 10:
		if (strt) {
			((Q10 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q10 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 9:
		if (strt) boq = from+1;
		if (strt) {
			((Q9 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q9 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 8:
		if (strt) {
			((Q8 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q8 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 7:
		if (strt) boq = from+1;
		if (strt) {
			((Q7 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q7 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 6:
		if (strt) {
			((Q6 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q6 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 5:
		if (strt) {
			((Q5 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q5 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 4:
		if (strt) boq = from+1;
		if (strt) {
			((Q4 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q4 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 3:
		if (strt) boq = from+1;
		if (strt) {
			((Q3 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q3 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 2:
		if (strt) boq = from+1;
		if (strt) {
			((Q2 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q2 *)z)->contents[slot].fld0 = fldvar;
		break;
	case 1:
		if (strt) boq = from+1;
		if (strt) {
			((Q1 *)z)->contents[slot].fld0 = 0;
		}
		if (fld == 0) ((Q1 *)z)->contents[slot].fld0 = fldvar;
		break;
	default: Uerror("bad queue - qrecv");
	}
}
int
q_cond(Trans *t)
{	int i = 0;
	for (i = 0; i < 6; i++)
	{	if (t->ty[i] == TIMEOUT_F) return 1;
		switch (t->qu[i]) {
		case 0: break;
		case 1: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.user_to_appl[0])
			 ||     q_full(now.user_to_appl[1])))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.user_to_appl[0])
			 ||    !q_full(now.user_to_appl[1])))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.user_to_appl[0])
			 ||     !q_len(now.user_to_appl[1])))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.user_to_appl[0])
			 ||      q_len(now.user_to_appl[1])))
			    ) return 0; break;
		case 2: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.appl_to_llc[0])
			 ||     q_full(now.appl_to_llc[1])))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.appl_to_llc[0])
			 ||    !q_full(now.appl_to_llc[1])))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.appl_to_llc[0])
			 ||     !q_len(now.appl_to_llc[1])))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.appl_to_llc[0])
			 ||      q_len(now.appl_to_llc[1])))
			    ) return 0; break;
		case 3: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.llc_to_appl[0])
			 ||     q_full(now.llc_to_appl[1])))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.llc_to_appl[0])
			 ||    !q_full(now.llc_to_appl[1])))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.llc_to_appl[0])
			 ||     !q_len(now.llc_to_appl[1])))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.llc_to_appl[0])
			 ||      q_len(now.llc_to_appl[1])))
			    ) return 0; break;
		case 4: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.regist_to_llc)))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.regist_to_llc)))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.regist_to_llc)))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.regist_to_llc)))
			    ) return 0; break;
		case 5: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.llc_to_regist)))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.llc_to_regist)))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.llc_to_regist)))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.llc_to_regist)))
			    ) return 0; break;
		case 6: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.leaveall_to_llc)))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.leaveall_to_llc)))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.leaveall_to_llc)))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.leaveall_to_llc)))
			    ) return 0; break;
		case 7: if (	(t->ty[i] == Q_FULL_F && ( q_full(now.llc_to_leaveall)))
			 || 	(t->ty[i] == Q_FULL_T && (!q_full(now.llc_to_leaveall)))
			 || 	(t->ty[i] == Q_EMPT_F && ( !q_len(now.llc_to_leaveall)))
			 || 	(t->ty[i] == Q_EMPT_T && (  q_len(now.llc_to_leaveall)))
			    ) return 0; break;
		default: Uerror("unknown qid - q_cond");
				return 0;
		}
	}
	return 1;
}
void
active_procs(void)
{
	Addproc(6);
}
